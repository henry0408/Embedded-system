# 1. 有关scanf

由于对字符解析方式及字符特点不同(e.g.数字中一般不会出现空格回车等特殊字符)，%d格式一般不会在连续输入时遇到问题。而%s和%c却会出现各种各样的问题，比如回车问题，空格问题等

## 1) 连续输入时的情况，对比下面两个代码块:

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf(" %c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf("%c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

会发现下面的代码块在%c处会出现问题。

* 原因：scanf的缓冲机制和对字符的处理方式就造成了scanf对字符%c和字符串%s的读取时的各种意外

* 分析：
输入了i的值为3然后按回车，当前缓冲区中数据为”3\n”，由回车的作用scanf开始从缓冲区中读取一个%d控制的数据，也就是3，此时缓冲区中还剩”\n”；
对下一个scanf函数的格式控制是%c，这个情况下并不忽略先导的空白字符\n，而是直接赋给字符c了。想要查看缓冲区的内容，stdin[s1] 

* 综上：
scanf函数，根据格式的不同，对空白字符的处理也不同。\
对%d来说，对空白字符不敏感，通常都是作为结束符的；\
对%c来说，对回车符比较敏感，空格的做为一个普通字符处理的；\
对%s来说，回车和空格都是当前函数的结束字符，由于缓冲区stdin机制，这里又要特别注意 空格和回车对%s的影响。\
%s默认分隔符是所有的 white-spaces，输入后自动加入结束符"\0"，使其成为一个字符串(之所以加上\0，是和字符数组char[]的结束符有关的，C中是没有string这个类型的，是使用char[]结构实现字符串)。\
值得注意的是，即使输入字符的长度足够，%s是宁愿舍弃输入字符，也要把/0加上去的，作为字符串的结束。并且，scanf会忽略缓冲区开头的空格，直到遇到一个非空格字符，才开始向内存中读取数据


## 2) 处理%d（不清除缓冲区）
```
    int i,j;

    scanf("%d",&i);
    printf("The number i is %d\n", i);

    char ch;
    while ((ch = getchar()) != '\n'){
         continue;
    }

    scanf("%d",&j);
    printf("The number j is %d\n", j);
    
```
中间getchar的目的：判断缓冲区（用户输入的下一个字符是不是换行符）\
举例：\
如果用户输入：1 aqsda asa， 在不加getchar的情况下，j的值为一个不合法的数字。

加了getchar之后，在1被赋值给i后，会开始判断下一个字符是不是换行符，如果不是，则一直进入循环，不给j赋值。


# 2. 有关continue
![image](https://user-images.githubusercontent.com/58734009/210924009-a043a3ba-072a-449e-809c-4129e6fb9d16.png)

### 1) 用于do...while
```
#include <stdio.h>
 
int main ()
{
   int a = 10;
   
   do
   {
      if( a == 15)
      {
         a = a + 1;
         continue;
      }
      printf("a 的值： %d\n", a);
      a++;
     
   }while( a < 20 );
 
   return 0;
}
```

a = 10, 不执行if，输出：a 的值：10\
a = 11, 不执行if，输出：a 的值： 11\
a = 12, 不执行if，输出：a 的值： 12\
a = 13, 不执行if，输出：a 的值： 13\
a = 14, 不执行if，输出：a 的值： 14\
a = 15，执行if，a++后跳出当前的do while，进入下一个do while

a = 16, 不执行if，输出：a 的值： 16\
a = 17, 不执行if，输出：a 的值： 17\
a = 18, 不执行if，输出：a 的值： 18\
a = 19, 不执行if，输出：a 的值： 19\
a = 20, while不执行

```
int main(void)
{
    int  i=0, s=0;
    do
    { 
	if(i%2)
	{
	    printf("yes, ");
            i++;
            printf("i = %d, ", i);
            printf("s = %d \n", s);
	    continue;
	}
        printf("no, ");
	i++;
	s+=i; 
        printf("i = %d, ", i);
        printf("s = %d \n", s);
    }while(i < 5); 
	
    printf("%d\n",s);   
    return 0;
}
```
输出：

no, i = 1, s = 1\
yes, i = 2, s = 1\
no, i = 3, s = 4\
yes, i = 4, s = 4\
no, i = 5, s = 9\
9

# 3. 一些简单算法
## 1）倒置一个数组：注意：倒置用到的是“互换”的概念，而不是反向输出（可以新建一个数组）
```
#include <stdio.h>
int main (void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int t;
    int i = 0;
    int j = 4;

    while (i<j){
        t = a[i];
        a[i] = a[j];
        a[j] = t;

        i = i+1;
        j = j-1;
    }

    for (int z = 0; z< 5; z++){
        printf("%d\n", a[z]);
    }

    return 0;
}
```
相当于需要先知道一个数组的长度，从i开始，与倒数第i个（j）互换。

## 2）判断一个数字是不是回文数
```
int main (void)
{
    int sum = 0;
    int val, num;

    printf("Please enter your num: \n");
    scanf("%d", &val);

    num = val;
    while (num) //只要num不是0就一直循环
    {
        sum = sum * 10 + num % 10;
        num /= 10;
    }

    if (sum == val){
        printf("Yes \n");
    }
    else{
        printf("No \n");
    }

    return 0;
}
```

## 3）求斐波拉契序列中第n项的值
1 2 3 5 8 13 21 34 ...

```
int main (void)
{
    int f1 = 1;
    int f2 = 2;
    int value = 0;

    printf("Please enter a number n: \n");

    int n;
    scanf("%d", &n);

    if (n == 1){
        value = f1;
    }
    else if (n == 2){
        value = f2;
    }
    else{
        for (int i = 3; i <= n; ++i){
            value = f1+f2;
            f1 = f2;
            f2 = value;
        }
    }

    printf("The value of the nth number is %d\n", value);
    
    return 0;
}
```
## 4）判断是不是素数
```
bool is_prime (int num){
    int i;
    for (i = 2; i<= num; i = i+1){ //这个不用担心最后i = num + 1会对if判断造成问题，因为直接break掉了，i最后不会再+1
        if (num % i == 0){ //如果只有本身可以整除，即为素数
            break;
        }
    }
    if (i == num){
        return true;
    }
    else{
        return false;
    }
}
```

# 4. 指针

内存的编号不是位（bit），而是字节（1 byte = 8 bit）

```
int * p;
```
p是变量的名字，int * 表示变量p存放的是int类型变量的地址。

错误表示：
```
int * p;
int i = 3;
p = i
```

正确表示：
```
int * p;
int i = 3;
p = &i; //取地址
```

错误表示：
```
int * p;
double i = 3.5;
p = &i;
```

概念：
* 1. p保存了i的地址， 也就是说**p指向i**
* 2. 修改p的值不影响i的值；修改i的值也不影响p的值
* 3. 互换： * p 表示以p的内容为地址的变量的值
	```
	int *p;
	int i;
	p = &i;
	*p = i;
	```
* 4. 指针变量**不等于**指针\
指针变量：p；指针：&i

### 易错1：与之前的赋值方法对比
```
#include <stdio.h>

int main (void)
{
    int * p;
    int i = 3;

    *p = i;

    printf("%d\n", *p);
    printf("%d\n", i);

    return 0;
}
```
所示例子，虽然可能不报错，但实际上是有问题的。\
int * p初始化的时候，p中其实（可能）存储了一个垃圾值。\
当使用* p = i时， 相当于把这个垃圾值作为地址的变量进行赋值。相当于把不属于我们的单元进行赋值了。

### 易错2：类型区分
```
#include <stdio.h>

int main (void)
{
    int i = 3;
    int * p;
    int * q;

    p = &i;
    *q = p;

    printf("%d\n", *q);

    return 0;
}
```
p的类型是：int *

然而* q的类型是：int\
导致* q = p时会出错

如果改成：
```
*q = *p;
```
这样写依旧有问题，因为q中依旧是一个垃圾地址，与pointer2.c问题一致

### 易错3：
对比下面两个代码块：
```
int main (void)
{
    int i = 3;
    int * p;
    int * q;

    p = &i;
    p = q;

    printf("%d\n", *p); //输出结果是垃圾值（而不是3），因为q中的内容是一个垃圾地址；q赋给p之后，p也是垃圾值

    return 0;
}
```
取* q时相当于把垃圾地址中的数值取出来；不能直接print * q的原因是：* q所代表的内存单元的权限并没有分配给本程序，所以会报错
```
int main (void)
{
    int i = 3;
    int * p;
    int * q;

    p = &i;
    p = q;

    printf("%d\n", *q);

    return 0;
}
```

### 易错4：野指针和StackOverflow
程序中有多个指针变量指向同一个内存单元，但free掉其中一个之后，就不能再free另一个了；\
如果一直不free，则会占用满内存，导致内存泄漏。

### 易错5：交换两个函数的值（利用指针的写法）
对比下面两个函数的区别：
```
#include <stdio.h>

void exchange(int * p, int * q){
    int * t;
    t = p;
    p = q;
    q = t;

    return;
}

void exchange2(int * p, int * q){
    int t;
    t = *p; //由于p是指向a的指针变量，那么*p = a；同理，*q = b
    *p = *q;
    *q = t;
}

int main (void){
    int a = 3;
    int b = 5;
    exchange(&a, &b);
    printf("a = %d, b = %d \n", a, b);

    exchange2(&a, &b);
    printf("a = %d, b = %d \n", a, b);

    return 0;
}
```
exchange这个函数不能实现数字互换，然而exchange2这个函数可以实现。\
在exchange这个函数中，* p存放的是a的地址，* q存放的是b的地址。相当于只对两者的地址进行了交换。\

然而在exchange2这个函数中，

下图左侧为exchange，右侧为exchange2：\
![9063e508b05bfadb7e4e1dc4ffbdaa9](https://user-images.githubusercontent.com/58734009/211459123-6b7d0b37-1190-4240-980a-0858c51c5ad3.jpg)

# 5. 数组和指针
## 1. 一维数组名其实是一个指针常量
查看数组第一位的地址：
```
int main (void)
{
    int a[5];
    int b[3][4];

    printf("%#X \n", &a[0]); //查看第一个元素的地址
    printf("%#X \n", &a); //查看数组地址，应该与第一个元素地址一样

    return 0;
}
```

## 2. 重点：由于数组名是一个指针常量，我们可以进一步推导出：
```
a[i] == *(a+i)
```

例子：返回数组的第i个值\
```
int main(void)
{
	int a[5] = {1,2,3,4,5};
	int i;

	for (i=0; i<5; ++i)
		// printf("%d\n", a[i]);  //a[i] == *(a+i) 
        printf("%d\n", *(a+i));  //a[i] == *(a+i) 

	return 0;
}
```

## 3. 通过一个函数输出数组所有内容
需要知道两个参数，一个是数组本身（相当于一个指针变量），另一个是数组长度。

数组和字符串不同，字符串结尾永远有一个\n，但数组最后一位不一定是什么，这也是我们需要数组长度作为参数的原因。
```
#include <stdio.h>

void print_all(int *p, int len)
{
    // 由array2.c可以知道，*p = a[0]， *(p+1) = a[1]

    for (int i = 0; i< len; i++){
        printf("%d\n", *(p+i));
    }
    return;
}

int main (void)
{
    int a[5] = {1, 2, 3, 4, 5};

    int b[3][4];

    print_all(a, 5); // a的类型为int *

    return 0;
}
```
## 4. 指针变量相减
只有相减才有意义，可以显示数组中两个变量的地址的差
```
int main (void)
{
    int * p;
    int * q;

    int a[5];
    p = &a[1];
    q = &a[3];

    printf("%d", q - p);

    return 0;
}
```
## 5. 指针变量占几个字节
```
int main (void)
{
    char ch = 'A';
    int num = 12;
    float val = 11.2;
    double val2  = 13.4;

    char * p = &ch;
    int * q = &num;
    float * t = &val;

    printf("The size of char is %d\n", sizeof(ch));
    printf("The size of int is %d\n", sizeof(num));
    printf("The size of float is %d\n", sizeof(val));
    printf("The size of double is %d\n", sizeof(val2));

    printf("The size of char * pointer is %d\n", sizeof(p));
    printf("The size of int * pointer is %d\n", sizeof(q));
    printf("The size of float * pointer is %d\n", sizeof(t));

    return 0;
}
}
```
发现指针变量占用的位数是一样的，都是8个字节（Byte），不同编译器不一样（32位的为4个Byte）

回顾，在内存中，一个内存单元以一个字节为一个编号； char占1个字节，int和float都是4个字节， double占8个字节， 每个变量用首字节编号作为该变量的编号。

问题1： 但是我们知道，指针变量指向的是一个变量中的第一个内存单元。那么当我们使用* p时，是如何得到对应变量的值的呢？\
答：因为我们定义了指针变量的类型。通过类型的不同，我们可以知道该变量占了多少字节。

问题2：那么为什么我们指针变量需要用8个字节呢？
答：指针变量保存的是对应变量的第一个内存单元的地址

## 6. 传统（静态）数组的缺陷
* 长度需要事先固定
* 数组内存无法手动释放，直到程序结束才会被释放
* 不能跨函数使用（函数运行期间可以被其他函数使用，但函数运行结束后，内存就会被释放）
