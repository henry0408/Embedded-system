# 黑马



## 1. 类和对象



### 1.1 new和delete

```
//申请空间
int* ptr = new int;

//申请空间并初始化
int* ptr2 = new int(1);
cout<<*ptr<<endl;		//1

//申请连续的空间，空间大小为4*10=40
int* arr = new int[10];//c++98不允许连续空间初始化

//释放单个空间
delete ptr;
delete ptr2;

//释放连续的多个空间
delete[] arr; 
```





### 1.2 深拷贝和浅拷贝

浅拷贝：简单的赋值拷贝操作

深拷贝：堆区重新申请空间，再进行拷贝操作



堆区：程序员手动开辟和释放

```
class Person
{
public:
	Person()
	{
		cout<<"默认构造"<<endl;
	}
	Person(int age, int height)
	{
		cout<<”有参构造""<<endl;
		m_age = age;
		m_height = new int(height);
	}
	~Person()
	{
		//将堆区开辟的数据进行释放
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
		
		cout<<"析构函数调用"<<endl;
	}
	
	int m_age;
	int *m_height;
}

void test()
{
    Person p1(18,160);
    cout<<"p1 age is "<<p1.age<<"height is "<<*p1.m_height<<endl;	//18
    
    Person p2(p1);
    cout<<"p2 age is "<<p1.age<<endl;	//18拷贝构造
}
```



对于析构函数，p2的析构会先被调用。因为栈是先进后出。

但这样写会出现问题。



对于`Person p2(p1)`来讲，利用编译器提供的拷贝构造函数，会做浅拷贝操作：

![image-20230614105841272](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230614105841272.png)

此时，因为p2先执行析构函数，导致堆区内存被释放，所以p1再执行析构函数时，会报错。（内存重复释放）



#### 浅拷贝带来的问题

堆区内存重复释放

所以要利用深拷贝：

![image-20230614110109611](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230614110109611.png)

此时，虽然m_height的数据相同，但是他们指向的是两个地址的数据。不会造成内存重复释放。



实现深拷贝：重写（自定义）拷贝构造函数

```
#include <iostream>

using namespace std;

class Person
{
public:
	Person()
	{
		cout<<"moren"<<endl;
	}
	Person(int age, int height)
	{
		cout<<"youcan"<<endl;
		m_age = age;
		m_height = new int(height);
	}

    //自己实现拷贝构造
	Person(const Person&p)
	{
		cout<<"kaobei"<<endl;
		//浅拷贝
		m_age = p.m_age;
		
		//m_height = p.m_height;		//编译器默认实现的是这行代码
		
		//深拷贝
		m_height = new int(*p.m_height);
	}

	~Person()
	{
		//将堆区开辟的数据进行释放
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
		
		cout<<"xigou"<<endl;
	}
	
	int m_age;
	int *m_height;
};

void test()
{
    Person p1(18,160);
    cout<<"p1 age is "<<p1.m_age<<" height is "<<*p1.m_height<<endl;	//18 160
    
    Person p2(p1);
    cout<<"p2 age is "<<p1.m_age<<" height is "<<*p2.m_height<<endl;//18 160自定义的拷贝构造
}

int main(int argc, char const *argv[])
{
    test();
    return 0;
}
```

输出

```
youcan
p1 age is 18 height is 160
kaobei
p2 age is 18 height is 160
xigou
xigou
```



**如果属性有在堆区开辟的，一定要自己写拷贝构造函数，防止浅拷贝带来的问题**



### 1.3 初始化列表

```
class Person
{
public:
	Person(int age):age(age){}
	
	int age;
};
```



### 1.4 类对象作为类成员

```
class A{};

class B
{
	A *a;
};
```

A为对象成员



问题：创建B对象时，A和B的构造和析构顺序？

```
#include <iostream>

using namespace std;

class Phone
{
public:
    Phone(string pname):m_pname(pname)
    {
        cout<<"Phone gouzao"<<endl;
    }
    ~Phone()
    {
        cout<<"Phone xigou"<<endl;
    }

    string m_pname;
};

class Person
{
public:
    //Phone m_Phone = pName 隐式转换
    Person(string name, string pName):m_name(name),m_phone(pName)
    {
        cout<<"person gouzao"<<endl;
    }
    ~Person()
    {
        cout<<"Person xigou"<<endl;
    }
    string m_name;
    Phone m_phone;
};

void test()
{
    Person p1("zhangsan","iphone");
    cout<<p1.m_name<< " " <<p1.m_phone.m_pname <<endl;
}

int main(int argc, char const *argv[])
{
    
    test();
    return 0;
}

```

输出：

```
Phone gouzao
person gouzao
zhangsan iphone
Person xigou
Phone xigou
```



总结：

**当其他类对象作为本类成员，构造时候先构造类对象，再构造自身**

**析构顺序与构造顺序相反**



### 1.5 静态成员

静态成员是成员变量和成员函数前加static



#### 1.5.1 静态成员变量

所有对象共享同一份数据

在编译阶段分配内存（全局区）

类内声明，类外初始化



```
class Person
{
public:
	
	//所有对象共享同一份
	static int m_A;
};

//类外初始化
int Person::m_A = 100;

int main()
{
	Person p;
	cout<<p.m_A<<endl;
	
	Person p2;
	p2.m_A = 200;
	
	cout<<p.m_A<<endl;
}
```



##### 静态成员变量两种访问方式

通过对象访问

通过类名访问

```
class Person
{
public:
	
	//所有对象共享同一份
	static int m_A;
};
//类外初始化
int Person::m_A = 100;

int main()
{
	//通过类名访问
	cout<<Person::m_A<<endl;
	
	//通过对象访问
	Person p;
	cout<<p.m_A<<endl;
}
```



##### 静态成员变量访问权限

```
class Person
{
private:
	
	//所有对象共享同一份
	static int m_A;
};

int Person::m_A = 10;

int main()
{
	//通过类名访问
	cout<<Person::m_A<<endl;	//报错inaccesible
}
```



#### 1.5.2 静态成员函数

所有对象共享同一个函数

只能访问静态成员变量



1）所有对象共享同一个函数：

```
class Person
{
public:
	static void func()
	{
		cout<<"static void func"<<endl;
	}
};

int main()
{
	//通过对象访问
	Person p;
	p.func();
	
	//通过类名访问
	Person::func();
}
```



2）只能访问静态成员变量：

```
class Person
{
public:
	static void func()
	{
		m_A = 100;
		m_B = 200;		//报错，静态成员函数只能访问静态成员变量
		cout<<"static void func"<<endl;
	}
	static int m_A;
	int m_B;	//非静态成员变量
	
	//静态成员函数也有访问权限
private:
	static void func2()
	{
		cout<<"func2"<<endl;
	}
};

int Person::m_A = 0;

int main()
{
	//通过对象访问
	Person p;
	p.func();
	
	//通过类名访问
	Person::func();
	
	Person::func2();	//报错，静态成员函数不能类外调用
}
```



### 1.6 成员变量和成员函数分开储存

c++中，类内成员变量和成员函数分开储存

只有非静态的成员变量才属于类的对象上



#### 空对象占用的空间：1字节

```
class Person
{

};

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```

原因：

C++编译器会给每个空对象也分配一个字节空间，为了区分空对象占内存的位置

每个空对象应该有一个独一无二的内存地址



#### 有非静态成员变量的类占用的空间

```
class Person
{
	int m_a;	//属于类的对象上
};

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//4
}

int main()
{
	test();
}
```



 #### 有静态成员变量的类占用的空间

静态成员变量不占用空间，不属于类的对象上

```
class Person
{
	static int m_a;	//静态成员变量，不属于类的对象上
};

int Person::m_a = 0;

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```



#### 非静态成员函数的类占用的空间

成员函数不占用空间，不属于类的对象上

```
class Person
{
	void func(){}
};


void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```



静态成员函数同样也不属于类的对象上



### 1.7 this指针

指向被调用的成员函数 所属的对象

目的：

- 解决命名冲突
- 返回类本身*this



this指针本质：指针常量，指向不可以修改。但指向的值可以修改



```
class Person
{
public:
	Person(int age)
	{
		this->age = age;
	}
	
	Person& PersonAddAge(Person &p)	//要返回本体，所以用引用类型
	{
		this->age += p.age;
		return *this;		//返回一个类
	}
	
	int age;
};

void test()
{
	Person p1(10);
	Person p2(10);
	
	p2.PersonAddAge(p1).PersonAddAge(p1);	//链式编程
	cout<<"age of p2: "<<p2.age<<endl;
}

int main(int argc, char const *argv[])
{
    test();
    return 0;
}
```

输出：

```
age of p2: 30
```



注意点：

返回值写成`Person &`类型，这样可以一直在当前类相加。否则最终结果为20。因为相当于第一次`p2.PersonAddAge(p1)`运行了，p2的age变成了20。但是，由于返回的是一个新的类型，相当于`新类型.PersonAddAge(p1)`，所以p2的值不会改变。



### 1.8 空的类指针访问成员函数

要注意有无this指针

```
class Person
{
public:
	void showClassName()
	{
		cout<<"This is Person class"<<endl;
	}
	
	void showPersonAge()
	{
		cout<<"age = "<<m_Age<<endl;
	}
	
	int m_Age;
};

void test()
{
	Person *p = NULL;
	
	p->showClassName();
	p->showPersonAge();	//报错
}

int main()
{
	test();
}
```

对于类中的对象，其实都存在一个this的指针：m_Age其实是this->m_Age

由于this本身就是NULL，所以肯定会报错



改进：

```
class Person
{
public:
	void showClassName()
	{
		cout<<"This is Person class"<<endl;
	}
	
	void showPersonAge()
	{
		if(NULL == this)
		{
			return;
		}
		cout<<"age = "<<m_Age<<endl;
	}
	
	int m_Age;
};

void test()
{
	Person *p = NULL;
	
	p->showClassName();
	p->showPersonAge();	//报错
}

int main()
{
	test();
}
```



### 1.9 const修饰

#### 1.9.1 修饰成员函数（常函数）

常函数：

- 成员函数后加const，我们称这个函数为常函数
- 常函数内不能修改成员属性
- 成员属性声明时加mutable关键字后，在常函数/常对象中仍然可以修改



我们知道，this是一个指针常量，指向是不可以改变的。

加了const其实修饰的是this指针，让指针指向的值也不可以被修改。

```
class Person
{
public:
	void showPerson() const
	{
		m_A = 100;		//报错
		this->m_A = 100;		//和上面一样，报错
		
		m_B = 200;		//可以修改
	}
	
	int m_A;
	mutable int m_B;	//加关键字
};
```



#### 1.9.2 修饰对象（常对象）

常对象：

- 声明对象前加const
- 常对象只能调用常函数/const成员变量



一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数）

```
class Person
{
public:
	void showPerson() const
	{
		m_B = 200;		//可以修改
	}
	
	void func()
	{
		m_A= 200;
	}
	
	int m_A;
	mutable int m_B;	//加关键字
};

void test()
{
	const Person p;
	p.m_A = 100;	//报错
	p.m_B = 300;	//可以修改
	
	p.showPerson();
	p.func();		//报错
}
```



注意：有些编译器g++中，不能直接声明`const Person p` ，需要自己写构造函数

```
#include <iostream>

using namespace std;

class Person
{
public:
    Person(int a, int b):m_A(a),m_B(b){}

    int m_A;
	mutable int m_B;	//加关键字

	void showPerson() const
	{
		m_B = 200;		//可以修改
	}
	
	void func()
	{
		m_A= 200;
	}
};

void test()
{
	const Person p(10,20);
	//p.m_A = 100;	//报错
	p.m_B = 300;	//可以修改
	
	p.showPerson();
    cout<<p.m_B<<endl;
	//p.func();		//报错
}

int main()
{
    test();
}
```

[关于C ++：未初始化的const | 码农家园 (codenong.com)](https://www.codenong.com/8092670/)

[c++ - 我真的需要为const对象实现用户提供的构造函数吗？ - IT工具网 (coder.work)](https://www.coder.work/article/7138240)



### 1.10 友元

可以让类外的一些函数或者其他类访问当前类中的私有属性的成员

关键字：friend



三种实现：

- 全局函数做友元
- 类做友元
- 成员函数做友元



#### 1.10.1 全局函数做友元

全局函数在类中加上friend关键字



```
class Building
{
	friend void visit(Building* building);
	
public:
	Building()
	{
		m_SittingRoom = "sr";
		m_BedRoom = "br";
	}
	
	string m_SittingRoom;
	
private:
	string m_BedRoom;
};

void visit(Building* building)
{
	cout<<"Visit sitting room "<< building->m_SittingRoom <<endl;
	cout<<"Visit bedroom "<< building->m_BedRoom <<endl;
}

int main()
{
	Building b;
	visit(&b);
}
```



#### 1.10.2 类做友元

在类中声明友元类。



##### 类外实现成员/构造函数

```
class Building;

class myFriend
{
public:
	myFriend();
	Building * building;
	void visit();	//参观函数，访问Building中的属性
};


class Building
{	
	friend class myFriend;
public:
	Building();
	string m_SittingRoom;
	
private:
	string m_BedRoom;
};


//类外实现成员构造
Building::Building()
{
	m_SittingRoom = "sr";
	m_BedRoom = "br";
}

myFriend::myFriend()
{
	//创建building类对象
	building = new Building;
}

void myFriend::visit()
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	cout<<"visiting "<<building->m_BedRoom<<endl;
}

void test()
{
	myFriend f;
	f.visit();
}

int main()
{
    test();
}
```



#### 1.10.3 成员函数做友元

类中申明另一个类中的函数加friend关键字

```
class Building;

class myFriend
{
public:
	myFriend();

	Building *building;
	
	void visit();
	void visit2();
};

class Building
{
	friend void myFriend::visit();	//告诉Building, myFriend下的visit成员函数为友元，可以访问私有内容。

public:
	Building();
	string m_SittingRoom;
private:
	string m_BedRoom;
};


Building::Building()
{
	m_SittingRoom = "sr";
	m_BedRoom = "br";
}

myFriend::myFriend()
{
	building = new Building;
}

void myFriend::visit()
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	cout<<"visiting "<<building->m_BedRoom<<endl;
}

void myFriend::visit2()
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	//cout<<"visiting "<<building->m_BedRoom<<endl;
}

void test()
{
	myFriend f;
	f.visit();
	f.visit2();
}

int main()
{
	test();
}
```



### 1.11运算符重载

对已有的运算符进行重定义



#### 1.11.1 加号运算符重载

实现两个自定义数据类型相加的运算



两种方法：

- 成员函数进行重载
- 全局函数进行重载



![image-20230615104341036](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230615104341036.png)



##### 1）成员函数重载运算符

```
class Person
{
public:
	int m_A;
	int m_B;
	Person operator+ (Person &p)
	{
		Person temp;
		temp.m_A = this->m_A + p.m_A;
		temp.m_B = this->m_B + p.m_B;
		return temp;
	}
};

void test1()
{
	Person p1;
	p1.m_A = 10;
	p1.m_B = 10;
	
	Person p2;
	p2.m_A = 10;
	p2.m_B = 10;
	
	Person p3 = p1+p2;	//本质：p3 = p1.operator+(p2)
	cout<<p3.m_A<<endl;
    cout<<p3.m_B<<endl;
}

int main()
{
    test1();
}
```



##### 2）全局函数重载运算符

```
class Person
{
public:
	int m_A;
	int m_B;
};

Person operator+ (Person &p1, Person &p2)
{
	Person temp;
	temp.m_A = p1.m_A + p2.m_A;
	temp.m_B = p1.m_B + p2.m_B;
	return temp;
}

void test1()
{
	Person p1;
	p1.m_A = 10;
	p1.m_B = 10;
	
	Person p2;
	p2.m_A = 10;
	p2.m_B = 10;
	
	Person p3 = p1+p2;	//本质：p3.operator+(p1,p2)
	cout<<"p3 m_A is "<<p3.m_A<<endl;
    cout<<"p3 m_B is "<<p3.m_B<<endl;
}

int main()
{
    test1();
}
```



##### 3）利用函数重载实现类和整型相加

基于上面的代码

```
Person operator+ (Person &p, int num)
{
	Person temp;
	temp.m_A = p.m_A + num;
	temp.m_B = p.m_B + num;
	return temp
}

void test2()
{
	Person p4;
	p4 = p1+20;
}
```

 

#### 1.11.2 左移运算符重载<<

可以输出自定义的类型



##### 1）利用成员函数重载(通常不用)

```
class Person
{
public:
	int m_A;
	int m_B;
	
	void operator<< (Person& p)
	{}
};
```

这样会出现一个问题，我们最后调用的时候会写成`p.operator<<(p)`，这样不符合我们想要的逻辑。而且无法实现cout在左侧



##### 2）利用全局函数

```
class Person
{
public:
	int m_A;
	int m_B;
};

void operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
}

void test()
{
	Person p;
	p.m_A = 10;
	p.m_B = 10;
	cout << p;
}

int main()
{
	test();
}
```



**Q1: 为啥重载函数的`ostream & cout`的参数必须是引用？**

因为不引用的话，相当于传值，也就是要拷贝一份cout对象，但是ostream里面的拷贝构造函数是protected的，无法拷贝。



**Q2: 连续地输出cout<<m<<endl;？**

上面的代码有一个问题，就是`cout<<p`后不能加endl。我们需要考虑链式编程，从而实现追加输出。

改正：返回一个输出流ostream引用类型

```
class Person
{
public:
	int m_A;
	int m_B;
};

ostream& operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
	return cout;
}

void test()
{
	Person p;
	p.m_A = 10;
	p.m_B = 10;
	cout << p << endl;
}

int main()
{
	test();
}
```



##### 3）如果是私有属性，利用友元函数:

```
class Person
{
	friend ostream& operator<< (ostream & cout, Person p);
priavte:
	int m_A;
	int m_B;
public:
	Person(int a, int b):m_A(a),m_B(b){}
};

ostream& operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
	return cout;
}

void test()
{
	Person p(10,10);
	cout << p << endl;
}

int main()
{
	test();
}
```





#### 1.11.3 递增运算符重载

![image-20230615150805263](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230615150805263.png)

步骤：

step1: 自定义整型

step2: 重载左移运算符

step3：重载（前置）递增运算符，注意返回值是本类的引用

```
class MyInteger
{
	friend ostream& operator<<(ostream& cout, MyInteger myint);
public:
	MyInteger()
	{
		m_Num = 0;
	}
	
	MyInteger& operator++()
	{
		m_Num++;
		return *this;
	}
	
private:
	int m_Num;
};

ostream& operator<<(ostream& cout, MyInteger myint)
{
	cout<< myint.m_Num;
	return cout;
}



void test()
{
	MyInteger myint;
	
	cout << myint << endl;
}

int main()
{
	test();
}
```



#### 1.11.4 赋值运算符重载

编译器自带的赋值运算是浅拷贝，如果我们把变量创建在堆区，释放时会出现重复释放的问题。

解决方法是对赋值运算符重载。



```
class Person
{
public:
	Person(int age){
		m_Age = new int (age);
	}
	
	int* m_Age;
	
	~Person()
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}
};

int main()
{
	Person p1(18);
	Person p2(20);
	
	p2 = p1;
}
```



出现的问题：浅拷贝导致释放两次

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230630105101685.png" alt="image-20230630105101685" style="zoom:80%;" />

解决方法：重载赋值运算符

```
class Person
{
public:
	Person(int age){
		m_Age = new int (age);
	}
	
	int* m_Age;
	
	~Person()
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}
	Person& operator =(Person &p)
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		
		m_Age = new int(*p.m_Age);
		return *this;
	}
};

int main()
{
	Person p1(18);
	Person p2(20);
	Person p3(30);
	
	p3 = p2 = p1;
	
	cout<<*p1.m_Age<<endl;
	cout<<*p2.m_Age<<endl;
	cout<<*p3.m_Age<<endl;
}
```



#### 1.11.5 关系运算符==, !=

两个自定义数据类型比较关系



```
class Person
{
public:
	string m_Name;
	int m_Age;
	
	Person(string name, int age)
	{
		m_Name = name;
		m_Age = age;
	}
	
	//重载关系运算符
	bool operator == (Person &p)
	{
		if(this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return true;
		}
		return false;
	}
	
	bool operator != (Person &p)
	{
		if(this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return false;
		}
		return true;
	}
	
};

void test01()
{
	Person p1("Tom", 18);
	Person p2("Tom", 18);
	
	if(p1 == p2)
	{
		cout<<"p1 equals to p2"<<endl;
	}
	else if(p1 != p2)
	{
		cout<<"p1 not equals to p2"<<endl;
	}
}
```



#### 1.11.6 函数调用运算符()

由于重载后使用的方式像函数的调用，因此称为仿函数

没有固定写法，非常灵活



```
class MyPrint
{
public:
	void operator () (string test)
	{
		cout << test <<endl;
	}

};

int main()
{
	MyPrint myPrint;
	myPrint("hello world");
	
	//匿名对象
	MyPrint()("hello world"); 
}
```



