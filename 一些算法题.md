[(33条消息) LeetCode：数组刷题（17道经典题目）_数组题目_奋斗的西瓜瓜的博客-CSDN博客](https://blog.csdn.net/qq_37085158/article/details/123668574)

链表：

[(33条消息) 链表专题 c/c++实现 LeetCode例题讲解_c++链表例题_RanLZ的博客-CSDN博客](https://blog.csdn.net/RangeLZ/article/details/97272742)



[ACM金牌选手整理的【LeetCode刷题顺序】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388470520)



大O表示法：

### 常见的大O运行时间（从快到慢）

- O(㏒n) 对数时间 比如二分查找
- O(n) 线性时间 比如简单查找
- O(n*㏒n) 比如快速排序
- O(n²) 比如选择排序
- O(n！) 比如旅行者问题
- 

先说下定义O(log2n)与O（n)的区别

O(log2n)含义说明：

比如123456789，你要找2，首先查中间元素5，大于2，所以直接排除掉5右边的6789，然后在1234里继续二分查找。每次排除1/2的元素，所以是O(log2n)。

O（n)含义说明：

n是元素的个数，O（n)意味着你把每个元素都访问一遍，这样你当然可以找到要查找的数了。但是对于有序数组，没必要这样遍历整个数组。
————————————————
版权声明：本文为CSDN博主「chenwch」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/heihu_malice7/article/details/90042912





## 1.给定一个数，判断这个数是否在该二维数组中。

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序

Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 14, return true.
Given target = 20, return false.

```
#include <stdio.h>

int main()
{
    int arr[5][5] = 
    {
        {1,   4,  7, 11, 15},
        {2,   5,  8, 12, 19},
        {3,   6,  9, 16, 22},
        {10, 13, 14, 17, 24},
        {18, 21, 23, 26, 30}
    };

    int num = 14;

    int col = 4;
    int row = 0;

    while (row>=0 && row<=4 && col >=0 && col <=4)
    {
        printf("%d %d\n",row,col);
        //printf("%d\n",arr[row][col]);
        
        if(arr[row][col] > num)
        {
            --col;
        }
        if(arr[row][col] < num)
        {
            ++row;
        }
        if(arr[row][col] == num)
        {
            printf("%d\n",num);
            break;
        }
    }
}
```
方法2：变成一个数组，排序后用二分法

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int arr[5][5] = 
    {
        {1,   4,  7, 11, 15},
        {2,   5,  8, 12, 19},
        {3,   6,  9, 16, 22},
        {10, 13, 14, 17, 24},
        {18, 21, 23, 26, 30}
    };

    int target = 14;

    int new_arr[25];
    int *p = &arr[0][0];
    for(int i=0; i<25; i++)
    {
        new_arr[i] = *(p+i);
    }

    for(int i=0; i<25; i++)
    {
        printf("%d ",new_arr[i]);
    }

    for(int i = 0; i<25-1;i++)
    {
        for(int j=0; j<25-1-i; j++)
        {
            if(new_arr[j]>new_arr[j+1])
            {
                int swap = new_arr[j];
                new_arr[j] = new_arr[j+1];
                new_arr[j+1] = swap;
            }
        }
    }

    int left = 0;
    int right = 25-1;

    while(left<right)
    {
        int mid = (left+right)/2;
        printf("mid is %d\n",new_arr[mid]);

        if(new_arr[mid] > target)
        {
            right = mid-1;
        }
        else if(new_arr[mid] < target)
        {
            left = mid+1;
        }
        else
        {
            printf("Find! The val is %d\n",new_arr[mid]);
            exit(-1);
        }
    }
    printf("Not found\n");
}
```



## 2. 把一个字符串中所有的空格替换成%20

难点：一个字符换成三个字符

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * new_arr(char *arr)
{
    int len = strlen(arr);
    printf("length is %d\n",len);
    int count = 0;      //判断有几个空格

    for(int i=0; i<len; i++)
    {
        if(arr[i] == ' ')
        {
            count++;
        }
    }
    printf("%d\n",count);

    char *p = (char*)malloc(sizeof(char)*(count*2+len+1));
    int j = 0, k = 0;
    while(j<len)
    {
        if(arr[j] == ' ')
        {
            //printf("%d %d\n",j,k);
            p[k] = '%';
            p[k+1] = '2';
            p[k+2] = '0';
            k+=3;
            j++;
        }
        else
        {
            p[k] = arr[j];
            j++;
            k++;
        }
    }
    return p;
}

int main()
{
    char *ch = "a b c";
    //printf("The len is %d\n",strlen(ch));

    char *p = new_arr(ch);
    printf("%s\n",p);
}
```

## 3. 二分法查找数组中是否存在一个元素

```
/*二分法查找*/

/*给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。（假设 nums 中的所有元素是不重复的。）*/

#include <stdio.h>

int find_val(int*arr, int length, int num)
{
    // left, right, mid是index
    int left = 0;
    int right = length-1;
    int mid;
    while(right >= left)        //如果右侧的index=左侧的index，意味着到了最中间的元素
    {
        mid = (right+left)/2;
        if(arr[mid]>num)
        {
            right--;
        }
        else if (arr[mid]<num)
        {
            left++;
        }
        else
        {
            printf("Exist\n");
            return mid;
        }
    }
    printf("Not exist\n");
    return -1;
}

int main()
{
    int arr[5] = {1,5,9,34,50};
    printf("The index is %d\n",find_val(arr, 5, 34));

    return 0;
}
```

复杂度为什么是O(logn)?

答：称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数。

总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。 

最差情况：运行k次。由于n/2^k取整后>=1，即令n/2^k=1， 可得k=log2n,（是以2为底，n的对数），所以[时间复杂度](https://so.csdn.net/so/search?q=时间复杂度&spm=1001.2101.3001.7020)可以表示O()=O(logn)。



## 4. 在排序数组中输出元素第一次出现和结束的位置

给定一个按照**升序**排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

二分法，左右滑动指针，来找到符合题意的区间

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。



## 5. 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```



## 6. leetcode 88合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

```
#include <stdio.h>

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int i=m-1;
    int j=n-1;
    int tail = m+n-1;
    
    while(i >= 0 || j >= 0)
    {
        if(nums1[i]>nums2[j])
        {
            nums1[tail] = nums1[i];
            tail--;
            i--;
        }
        else if(nums1[i]<=nums2[j])
        {
            nums1[tail] = nums2[j];
            tail--;
            j--;
        }
        else if(i <0)
        {
            nums1[tail] = nums2[j];
            tail--;
            j--;
        }
        else if(j<0)
        {
            nums1[tail] = nums1[i];
            tail--;
            i--;
        }
    }
}

int main()
{
    int nums1[6] = {1,2,3,0,0,0};
    int m = 3;
    int nums2[3] = {2,5,6};
    int n = 3;
    merge(nums1, 6, m, nums2, 3, n);
    for(int i = 0; i<6;i++)
    {
        printf("%d ",nums1[i]);
    }
    printf("\n");
    return 0;
}
```

思路：i，j表示两个数组最后一个元素的index，从后向前遍历。哪个大，把那个塞到nums1的最后的空的元素的位置（index = tail）

时间复杂度：O(m+n)O(m+n)O(m+n)。 指针移动单调递减，最多移动 m+nm+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)O(m+n)。

空间复杂度：O(1)O(1)O(1)。 直接对数组 nums1\textit{nums}_1nums 
1

  原地修改，不需要额外空间

作者：力扣官方题解
链接：https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 7. 找出数组中重复的数字

在一个长度为 n 的一维数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。找出数组中重复的元素并返回该元素，如果没有重复则返回-1

```
int findRepeatNumber(int*arr, int len)
{
	int i = 0;
	while(i<len)
	{
		if(arr[arr[i]] == arr[i])
		{
			return arr[i];
		}
		else
		{
			if(arr[i] == i)
            {
                i++;
                continue;
            }
            else
            {
            	int temp = arr[i];
            	arr[i] = arr[temp];
            	arr[temp] = temp;
            }
		}
	}
	printf("no repeated num\n");
	return -1;
}

int main()
{
    int arr[10] = {3,8,2,1,4,5,6,7,8,9};
    int ans;
    ans = findRepeatNumber(arr, 10);

    printf("%d\n", ans);

    return 0;
}
```

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230422123559035.png" alt="image-20230422123559035" style="zoom:40%;" />

## 8. 剑指offer11. lc 154. 旋转数组的最小数字

本题和「154. 寻找旋转排序数组中的最小值 II」完全相同，是「153. 寻找旋转排序数组中的最小值」的延伸。读者可以先尝试第 153 题，体会在旋转数组中进行二分查找的思路，再来尝试解决本题。

作者：力扣官方题解
链接：https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的**最小元素**。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 1。 

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

```
输入：numbers = [3,4,5,1,2]
输出：1
```

```
输入：numbers = [2,2,2,0,1]
输出：0
```

```
#include <stdio.h>

int minArray(int* nums, int numbersSize)
{
	int left = 0;
	int right = numbersSize-1;
	while (left<right)
	{
		int mid = (left+right)/2;
        printf("%d %d %d\n",mid, left, right);
		
		//注意：不存在numbers[left] < numbers[right]的情况
		if((right-left) == 1)
		{
			printf("*******\n");
            return nums[right];
		}
		else if(nums[mid]>=nums[left])      //注意：一定要写等于号，不然例子3会出问题
		{
			left = mid;
		}
		else if(nums[mid]<=nums[right])
		{
			right = mid;
		}
	}
}

int main()
{
	int arr[5] = {2,4,6,0,1};
	int ans = minArray(arr,5);
	printf("%d\n",ans);             //输出0

    int arr1[7] = {2,4,4,6,1,2,2};
	int ans1 = minArray(arr1,7);
	printf("%d\n",ans1);            //输出1

    int arr2[7] = {2,2,2,2,2,1,2};
	int ans2 = minArray(arr2,7);
	printf("%d\n",ans2);            //输出1
}
```



## 8.5 lc153. 寻找旋转排序数组中的最小值（上题简化）

[153. 寻找旋转排序数组中的最小值 - 力扣（Leetcode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/)



## 9. leetcode19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

```
输入：head = [1], n = 1
输出：[]
```

```
输入：head = [1,2], n = 1
输出：[1]
```

#### 方法1：

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;

    struct ListNode* len = dummy;
    
    int length = 0;
    // while (head != NULL) {
    //     head = head->next;
    //     length ++;
    // }

    while(len->next != NULL)
    {
        length++;   
        len = len->next;  
    }

    printf("length is %d\n",length);
    
    struct ListNode* cur = dummy;
    for (int i = 0; i < length - n; ++i) {
        cur = cur->next;
    }
    cur->next = cur->next->next;
    struct ListNode* ans = dummy->next;
    free(dummy);
    return ans;

}
```



步骤：先计算出链表长度，链表长度减去n即为要删除的元素的前一个元素

采用哨兵节点：原因是如果删除的元素是头节点的话，会方便操作



链表长度计算：两种选其一：注意不能用dummy节点，让dummy节点固定在head的前面

```
// while (head != NULL) {
//     head = head->next;
//     length ++;
// }

while(len->next != NULL)
{
    length++;   
    len = len->next;  
}
```



#### 方法2：

双指针，fast和slow之间隔了n个时，同时开始遍历，知道fast指向NULL（最后一个元素的下一个）。这样slow的下一个元素就是要删除的元素。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;

    struct ListNode* fast = dummy;
    struct ListNode* slow = dummy;

    for(int i = 0; i<n+1; i++)		//注意n+1
    {
        fast = fast->next;
    }

    while(fast != NULL)
    {
        fast = fast->next;
        slow = slow->next;
    }

    slow->next = slow->next->next;
    
    struct ListNode* ans = dummy->next;
    free(dummy);
    return ans;

}
```

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230424205827786.png" alt="image-20230424205827786" style="zoom:40%;" />

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230424205846322.png" alt="image-20230424205846322" style="zoom:35%;" />

## 10. leetcode 21. 合并两个有序链表

[21. 合并两个有序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

#### 方法1：双指针

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
    struct ListNode* cur1 = list1;
    struct ListNode* cur2 = list2;

    struct ListNode* new_head = malloc(sizeof(struct ListNode));
    struct ListNode* pTail = new_head;

    while(1)
    {
        if(cur1 == NULL)
        {
            pTail->next = cur2;
            break;
        }
        if(cur2 == NULL)
        {
            pTail->next = cur1;
            break;
        }
        
        if(cur1->val < cur2->val)
        {
            pTail->next = cur1;
            cur1 = cur1->next;
            pTail = pTail->next;
        }
        else
        {
            pTail->next = cur2;
            cur2 = cur2->next;
            pTail = pTail->next;
        }

    }
    return new_head->next;
}
```



#### 方法2：递归

[21. 合并两个有序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)



## 11. leetcode 876 链表的中间节点

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

[876. 链表的中间结点 - 力扣（Leetcode）](https://leetcode.cn/problems/middle-of-the-linked-list/)



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* middleNode(struct ListNode* head){
    int length = 1;
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;
    struct ListNode* pNode = dummy;

    struct ListNode* pLen = head;
    if(head == NULL)
    {
        return NULL;
    }
    while(pLen != NULL)
    {
        length++;
        pLen = pLen->next;
    }
    length--;
    printf("The length is %d\n",length);

    int mid;
    mid = length/2;
    
    printf("The mid is%d\n",mid);

    for(int i = 0; i<= mid; i++)
    {
        pNode = pNode->next;
    }
    printf("The val is %d\n",pNode->val);

    return pNode;

}
```



## 12. leetcode 83. 删除排序链表中的重复元素

[83. 删除排序链表中的重复元素 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)



关键点：重复的元素在链表中出现的位置是连续的！！！所以判断pNode->next->next和pNode->next即可

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteDuplicates(struct ListNode* head){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;
    struct ListNode* pNode = dummy;
    // if (!head || !(head->next))
    //     return head;
    if(dummy->next == NULL)
    {
        return dummy->next;
    }

    while(pNode->next->next != NULL)
    {
        //printf("%d ",pNode->next->val);
        //pNode = pNode->next;
        
        if(pNode->next->val ==  pNode->next->next->val)
        {
            pNode->next = pNode->next->next;
        }
        else
        {
            pNode = pNode->next;
        }
    }
    return dummy->next;
}
```

注意加上第一个`dummy->next == NULL`判断：[83. 删除排序链表中的重复元素 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/2229939/shan-chu-lian-biao-xiang-tong-jie-dian-b-8811/)

