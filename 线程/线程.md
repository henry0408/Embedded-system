# 线程

为什么有了进程还要引入线程？

## 1. 概念

1)**轻量级的进程** 也有pcb(进程控制块)但没有独立的地址空间(共享) 

应用层  进程 线程

2)**是系统调度的最小单位** 由进程创建 多个线程共享进程资源 **每个线程有唯一的标识 tid** 

主线程：main开始运行的线程  



## 2. 特点

1）**进程可以创建线程 多个线程共享进程资源** **进程结束 线程一定结束** 

2）不同线程 完成不同任务 共同为进程服务

3）一个进程的多个线程共享以下资源:静态数据 进程中打开的文件描述符 当前工作目录 

4）线程使用时 需要加载第三方的库  编译 -pthread  

5）**线程执行的先后顺序不确定 通过sleep控制**



**注意编译：gcc pthread.c -pthread** 



## 3. 函数

| 作用   | 进程函数 | 线程函数       |
| ------ | -------- | -------------- |
| 创建   | fork     | pthread_create |
| 退出   | exit     | pthread_exit   |
| 阻塞   | wait     | pthread_join   |
| 获取id | getpid   | pthread_self   |

​    

### 3.1 创建子线程: pthread_create()

```
  #include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);

​    Compile and link with -pthread.


不能用perror错误处理 strerror(ret)
    功能：创建线程 

//参数：

​      thread：线程ID号 

​      attr:线程属性 NULL 表示默认 

​      start_routine:线程处理函数

​      arg:传递给线程处理函数的参数

//返回值：成功返回0 失败-1   
```

#### 例子1：主线程为子线程传参

```
#include "apue.h"

void * pthread_fun(void *p)
{
	printf("%d\n", *(int*)p);
}

int main()
{
	int a = 666;
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, &a);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	printf("hello\n");
}
```

**注意：pthread_fun()函数中，要为传进去的p强转类型。**

输出：

```
hello
666
```

（顺序不固定）



#### 例子2：主/子线程结束顺序

```
#include "apue.h"

void * pthread_fun(void *p)
{
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
}
```

输出：

```
*.*.
```

原因：进程（主线程）结束，子线程也会结束。所以不会输出5个*



改进：主线程为子线程收尸



#### 例子3：线程返回值

```
#include "apue.h"

void *pthread_fun(void *)
{
	return (void*)0x8888;
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	
	void *value = NULL;
	pthread_join(tid, &value);
	printf("%p\n",value);		//0x8888
}
```





### 3.2 阻塞收尸: pthread_join()

```
#include <pthread.h> 

int pthread_join(pthread_t thread, void **retval); 

​    Compile and link with -pthread.

​    功能：以阻塞形式等待指定线程

//参数
1. 线程id号
2. NULL

​    返回值：成功返回0 失败-1 
```

```
#include "apue.h"

void * pthread_fun(void *p)
{
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
	pthread_join(tid, NULL);
}
```

输出：

```
*.*.***
```



### 3.3 获取线程ID号: pthread_self()

```
#include "apue.h"

void * pthread_fun(void *p)
{
	printf("pthread_fun: %lu\n",pthread_self());
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	printf("main start: %lu\n",pthread_self());
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
	pthread_join(tid, NULL);
	printf("main end: %lu\n",pthread_self());
}
```

发现：

只有pthread_fun函数中是子线程，其他都是主线程



### 3.4 进程的全局变量是线程的全局变量(共享的)：

与进程不同，线程之间共享全局变量

例子：创建两个子线程，交替打印"i am thread1...." "i am thread2..."

```
#include "apue.h"

int flag = 0;
void* pthread _fun1(void* p)
{
	while(1)
	{
		if(0 == flag)
		{
			puts("i am thread1");
			flag = 1;
		}
		sleep(1);
	}
}

void* pthread_fun2(void* p)
{
	while(1)
	{
		if(1 == flag)
		{
			puts("i am thread2");
			flag = 0;
		}
		sleep(1);
	}
}

int main()
{
	pthread tid1, tid2;
	int ret1 = pthread_create(&tid1, NULL, pthread_fun1, NULL);
	if(ret1<0)
	{
		printf("%s\n",strerror(ret1));
		exit(-1);
	}
	int ret2 = pthread_create(&tid2, NULL, pthread_fun2, NULL);
	if(ret2<0)
	{
		printf("%s\n",strerror(ret2));
		exit(-1);
	}
	
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
}
```



## 4. 线程同步与互斥

### 4.1 概念

#### 1）互斥

**互斥**：指某一资源同时只允许一个访问者对其进行访问 具有唯一性和排他性

​    但互斥无法限制访问者对资源的访问顺序 访问是无序 

线程互斥：相互线程间是互斥访问  目的是保证共享数据操作的完整性



**临界资源：** 是指在同一个时刻只允许有限个任务可以访问或修改的资源，通常包括硬件资源（CPU、内存、外设等）和软件资源（共享代码段、共享结构、变量等）



**什么是临界区？**
进程中访问临界资源的 那段程序代码 称为临界区

 

互斥锁 

条件变量

 

#### 2）同步

**同步**: 同步即协同步调，按预定的先后次序运行 在互斥基础上 通过其他机制实现 访问者对资源有序访问 

线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。

信号量



### 4.2 线程同步（信号量）

#### 4.2.1 信号量值-1：sem_wait()

```
#include <semaphore.h>
    
int sem_wait(sem_t *sem);
```



#### 4.2.2 信号量值+1：sem_post()

```
 #include <semaphore.h>

int sem_post(sem_t *sem);
```



#### 4.2.3 初始化一个信号量的值为value：sem_init()

```
 #include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);

​    功能：初始化一个信号量的值为value 

//参数： 

​    sem ：信号量 

​    pshared：是否在进程间使用 一般是0 表示不在进程间使用 

​    value ：信号量的值   

//返回值：成功返回0 失败-1 
```



#### 4.2.4 销毁一个信号量：sem_destroy()

```
int sem_destroy(sem_t *sem);
```



#### 例子

````
#include "apue.h"

sem_t s;
void* pthread_fun1(void* p)
{
	sleep(3);
	puts("i am fun...");
	sem_post(&s);
}

void* pthread_fun2(void* p)
{
	sem_wait(&s);	
	puts("i am fun 1...");
	
}

int main()
{
	pthread_t tid1, tid2;
	
	sem_init(&s,0,0);
	
	int ret1 = pthread_create(&tid1, NULL, pthread_fun1, NULL);
	if(ret1<0)
	{
		printf("%s\n",strerror(ret1));
		exit(-1);
	}
	int ret2 = pthread_create(&tid2, NULL, pthread_fun2, NULL);
	if(ret2<0)
	{
		printf("%s\n",strerror(ret2));
		exit(-1);
	}
	
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	
	sem_destroy(&s);
}
````

