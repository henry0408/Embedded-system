# 1. 有关scanf

由于对字符解析方式及字符特点不同(e.g.数字中一般不会出现空格回车等特殊字符)，%d格式一般不会在连续输入时遇到问题。而%s和%c却会出现各种各样的问题，比如回车问题，空格问题等

## 1) 连续输入时的情况，对比下面两个代码块:

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf(" %c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf("%c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

会发现下面的代码块在%c处会出现问题。

* 原因：scanf的缓冲机制和对字符的处理方式就造成了scanf对字符%c和字符串%s的读取时的各种意外

* 分析：
输入了i的值为3然后按回车，当前缓冲区中数据为”3\n”，由回车的作用scanf开始从缓冲区中读取一个%d控制的数据，也就是3，此时缓冲区中还剩”\n”；
对下一个scanf函数的格式控制是%c，这个情况下并不忽略先导的空白字符\n，而是直接赋给字符c了。想要查看缓冲区的内容，stdin[s1] 

* 综上：
scanf函数，根据格式的不同，对空白字符的处理也不同。\
对%d来说，对空白字符不敏感，通常都是作为结束符的；\
对%c来说，对回车符比较敏感，空格的做为一个普通字符处理的；\
对%s来说，回车和空格都是当前函数的结束字符，由于缓冲区stdin机制，这里又要特别注意 空格和回车对%s的影响。\
%s默认分隔符是所有的 white-spaces，输入后自动加入结束符"\0"，使其成为一个字符串(之所以加上\0，是和字符数组char[]的结束符有关的，C中是没有string这个类型的，是使用char[]结构实现字符串)。\
值得注意的是，即使输入字符的长度足够，%s是宁愿舍弃输入字符，也要把/0加上去的，作为字符串的结束。并且，scanf会忽略缓冲区开头的空格，直到遇到一个非空格字符，才开始向内存中读取数据

