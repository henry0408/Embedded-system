# 位移运算符trick



## 1. C语言中数据二进制存储

是以**补码**的形式存储的

十进制的5（32位）

```
00000000 00000000 00000000 00000101
```



原码：

一个正数，按照绝对值大小转换成的二进制数；

一个负数按照绝对值大小转换成的二进制数，然后最高位补1。

```
00000000 00000000 00000000 00000101		//5的原码
10000000 00000000 00000000 00000101		//-5的原码
```

反码：

正数的反码***与原码相同***

负数的反码为对该数的原码除符号位外各位取反

```
00000000 00000000 00000000 00000101		//5的反码
11111111 11111111 11111111 11111010		//-5的反码
```

补码

正数的补码与原码相同

负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

```
00000000 00000000 00000000 00000101		//5的补码
11111111 11111111 11111111 11111011		//-5的补码
```



所以，-5在计算机中表达为：11111111 11111111 11111111 11111011。十六进制为0xFFFFFFFB



```
unsigned long val = 0; 
char a = 0x48; 
char b = 0x52; 
val = b << 8 | a; 
```

​	A 20992 		B 21064 			C 72 			D 0    答案：B

```
unsigned long val = 0; 
char a = 0x48; 
char b = 0x52; 
val = b << 8 | a; 
------------------
a 0100 1000
b 0101 0010 << 8   0101 0010  0000 0000
		   0100 1000
0101 0010  0000 0000

0101 0010  0100 1000
16384+4096+512+64+8=21064 
```

1. 规则

   丢弃最高位(***符号位同样丢弃***)，0补最低位

2. 在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方

3. 如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位



## 1. 右移运算符

1. 规则：符号位不变，左边补上符号位。
2. **按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1**









ref:

[(33条消息) 移位运算符＜＜ ＞＞ ＞＞＞的使用_移位运算符的使用_一只有理想的程序猿的博客-CSDN博客](https://blog.csdn.net/weixin_39674445/article/details/111684003?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link)



