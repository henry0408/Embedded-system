# 进程

## 一. 相关概念

### 1. 进程和程序

进程：正在运行的程序（一个程序的一次执行的过程）；进程是程序的载体



进程和程序的区别：

1. 程序是静态的。包含数据段/正文段。它是保存在磁盘上的指令的有序集合，没有执行的概念。

2. 进程是动态的。是程序执行的过程。包含数据段/正文段/堆栈段

   执行过程：创建，调度，消亡；

   是一个抽象实体，系统执行程序时，分配和释放的各种资源；

   进程是程序执行和资源管理的最小单位 。



### 2. 进程状态

1. 初始态 

2. 就绪态

   进程已经获得除CPU以外的所有必要资源，只等待CPU时的状态。

   系统会将多个处于就绪状态的进程排成一个就绪队列。  

3. 执行态 

   进程已经获取CPU，正在执行。单片机中，处于执行状态的进程只有一个；多处理系统中，有多个处于执行状态的进程。

4. 阻塞态 

   正在执行的进程由于某种原因而暂时无法继续执行，便放弃处理机而处于暂停状态，即进程执行受阻。（这种状态又称等待状态或封锁状态）

5. 结束态



#### 进程控制块：PCB

 vim /usr/src/linux-headers-3.2.0-29/include/linux/sched.h  //1227行

进程的内存结构： linux 采用虚拟内存管理技术，使得每个进程都有独立的地址空间。



### 3. 进程的模式（用户&内核）

用户模式&内核模式

[深入User space(用户空间) 与 Kernel space(内核空间) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/592581594)



#### 1）虚拟内存空间

虚拟地址空间：32位操作系统内存一共只有4G，但操作系统为每一个进程都分配了4G的内存空间，这个内存空间实际是虚拟的，虚拟内存到真实内存有个映射关系。

操作系统将这4G可访问的内存空间分为二部分，一部分是内核空间，一部分是用户空间。

![img](https://pic4.zhimg.com/80/v2-bac324aa2fb63562d2ee6bcc397d1ae7_720w.webp)

内核空间1G，用户空间3G



**区分内核和用户空间的原因：**

用户态的程序不能随意操作内核地址空间，这样对操作系统具有一定的安全保护作用。

如果应用程序能访问任意内存空间，如果程序不稳定常常把系统搞崩溃，比如清除操作系统的内存数据。

后来觉得让应用程序随便访问内存太危险了，就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0~Ring3 (和电影分级有点像)。

linux 只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。

![img](https://pic2.zhimg.com/80/v2-93c7015c4ca8888277406aa248d4a3d9_720w.webp)





#### 2）内核态&用户态

**当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。**

内核态下，CPU可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。

在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的很多检查，比如：进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。

<img src="https://pic4.zhimg.com/80/v2-f7d5d36ac5eee4fadd43e9d064e267cf_720w.webp" alt="img" style="zoom: 80%;" />



### 4. 进程的一生

1. 出生fork

2. 任务execl

3. 结束exit()



#### 僵尸进程和孤儿进程

 僵尸进程：父进程没消亡 但不为子进程收尸  子进程是僵尸进程 避免僵尸进程    

   孤儿进程：父进程消亡 子进程还在运行 这时 子进程是孤儿进程 会被init进程领养并收尸

### 5. 进程的ID（PID）

init进程是进程祖先 PID 是1		

ps aux 查看所有用户所有进程详细信息

pstree 查看进程树

top 动态查看进程信息



## 二. 进程系统调用

### 1. 进程查看以及创建

#### 1.1 获取进程ID：getpid

```
 #include <sys/types.h>
 #include <unistd.h>

​    pid_t getpid(void);//pid_t  是int别名 
​	  功能：获取当前调用进程PID

​    pid_t getppid(void);
​	  功能：获取当前调用进程的父进程的PID
```

```
int main()
{
	printf("%d, %d\n",getpid(),getppid());
}
```



#### 1.2 创建新进程fork()

```
#include <unistd.h> 

pid_t fork(void);

​	功能：创建新进程

​	返回值：成功调用返回两次 在父进程中返回子进程PID 在子进程中返回0

​	出错返回-1	
```



#### 1.3 如何区分两个进程

根据fork的返回值

```
int main()
{
	printf("main pid: %d\n",getpid());
	pid_t id = fork();
	if(id == 0)
	{
		printf("我是子进程: %d，我的父进程是%d\n",getpid(),getppid());
	}
	else if(id > 0)
	{
		sleep(1);	//目的让子进程先走完
		printf("我是父亲:%d\n",getpid());
	}
}
```

sleep(1);	//目的让子进程先走完，如果不加sleep，父进程可能先走完，走完后子进程的父进程变成init（pid = 1)。

而且发现`linux@ubuntu: ~$`不再出现，可是可以在CLI输入其他任意指令（说明不是死循环）。

原因：`linux@ubuntu: ~$`是由shell脚本控制的，在一个死循环中，终端控制权是main进程，我们输入Crtl+c，会将终端控制权回归给shell

![image-20230509210841451](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230509210841451.png)



#### 1.4 父子进程的执行顺序

先后顺序不确定，取决于系统调度策略



#### 1.5 总结：

1.子进程复制父进程的数据空间 堆栈 代码段(共享正文段)

2.复制后 两个进程空间完全独立 子进程变量改变 父进程不会影响

实例：sleep控制进程执行先后顺序



### 2. 进程消亡

#### 2.1 进程终止方式

````
有8种方式使进程终止，其中前5种为正常终止，它们是

1：从 main 返回
2：调用 exit
3：调用 _exit 或 _Exit
4：最后一个线程从其启动例程返回
5：最后一个线程调用 pthread_exit


异常终止有3种，它们是
6：调用 abort()
7：接到一个信号并终止
8：最后一个线程对取消请求做出响应

函数名: abort
功 能: 异常终止一个进程
用 法: void abort(void);
头文件：#include <stdlib.h>

说明：abort函数是一个比较严重的函数，当调用它时，会导致程序异常终止，
````



#### 2.2 exit和_exit和return

两者都是结束进程（整个程序），_exit是立即结束（不刷新IO缓存），exit会刷新缓存

```
void fun()
{
	printf("hello");	//注意没有\n
	exit(0);
}
int main()
{
	fun();
	puts("end");
}

//输出结果hello
```

```
void fun()
{
	printf("hello");	//注意没有\n
	_exit(0);
}
int main()
{
	fun();
	puts("end");
}

//输出结果: 什么都没有，说明没有刷新缓冲区
```

```
void fun()
{
	printf("hello\n");	//注意没有\n
	_exit(0);
}
int main()
{
	fun();
	puts("end");
}

//输出结果:hello
```

```
int fun()
{
	printf("hello\n");	//注意没有\n
	return 0;
}
int main()
{
	fun();
	puts("end");
}

//输出结果:hello\n end
```



### 3. 进程收尸

#### 3.1 阻塞wait

```
#include <sys/types.h>
#include <sys/wait.h>

//收尸+遗产
pid_t wait(int *status);//scanf()

//功能：
等待一个子进程结束 取得子进程结束的状态 将其保存在status中

//返回值：返回被收尸的子进程PID 如果没有子进程返回-1

//注意： 
​	a、父进程调用wait时 父进程会阻塞等待子进程结束
​	b、如果父进程不关心子进程退出的状态  wait参数可以传NULL 就丢弃结束信息
​	c、wait后 子进程占用的资源会被释放

//参数：status 如果为空 就丢弃结束信息
WIFEXITED(status) 判断是否正常退出 真--正常退出 假 是异常退出
WEXITSTATUS(status) 取得进程结束时的返回值
WIFSIGNALED(status) 判断进程是否被信号终止 如果是 则返回真
WTERMSIG(status)  判断是被哪个信号终止的
  
```

例子1：读取收尸的子进程id

```
int main()
{
	pid_t id = fork();
	if(0 == id)
	{
		printf("child: %d\n",getpid());
	}
	else if(id > 0)
	{
		puts("father");
		pid_t wpid = wait(NULL);
		printf("wpid is %d\n",wpid);
	}
	else
	{
		perror("fork");
		exit(-1);
	}
}
```

例子2：读取退出状态

```
int main()
{
	pid_t id = fork();
	if(0 == id)
	{
		printf("child: %d\n",getpid());
		exit(666);
	}
	else if(id > 0)
	{
		puts("father");
		int s;
		pid_t wpid = wait(&s);
		printf("%d\n",WIFEXITED(s));	//正常结束，返回1
		printf("%d\n",WEXITSTATUS(s));	//666
	}
	else
	{
		perror("fork");
		exit(-1);
	}
}
```

例子3：判断是被哪个信号终止的

```
int main()
{
	pid_t id = fork();
	if(0 == id)
	{
		printf("child: %d\n",getpid());
		int a = 10, b = 0;
		int c = a/b;
	}
	else if(id > 0)
	{
		puts("father");
		int s;
		pid_t wpid = wait(&s);
		printf("%d\n",WIFEXITED(s));	//正常结束，返回1
		printf("%d\n",WEXITSTATUS(s));	//1
		printf("%d\n",WTERMSIG(status));	8
	}
	else
	{
		perror("fork");
		exit(-1);
	}
}
```

因为除法不能除以0，所以信号8会终止进程

所有的终止信号可以用`kill -l`查看



#### 3.2 指定给哪个子进程收尸：waitpid

一个父进程可以有好多个子进程，waitpid可以给指定的子进程收尸

```
pid_t waitpid(pid_t pid, int *status, int options);

//功能：为指定pid的进程收尸

//参数
pid：
	pid<-1  等待其进程组组长ID（GID)等于pid的绝对值的任意子进程
	pid==-1  该进程任意子进程
	
status:
    如果为空 就丢弃结束信息
    WIFEXITED(status) 判断是否正常退出 真--正常退出 假 是异常退出
    WEXITSTATUS(status) 取得进程结束时的返回值
    WIFSIGNALED(status) 判断进程是否被信号终止 如果是 则返回真
    WTERMSIG(status)  判断是被哪个信号终止的

options：可以决定是否等待子进程结束
	0：等待子进程结束
	WNOHANG：不等待
	
//返回值
>0 被收尸的子进程的PID 
0  参数3用WNOHANG 且没有子进程退出
-1 出错
```



例子1: `waitpid(-1,&sta,0)`等价于`wait(&sta)`

```
#include "apue.h"

int main()
{
	pid_t id = fork();
	if(0 == id)
	{
		printf("child\n");
	}
	else if(id >0)
	{
		waitpid(-1,NULL,0);
		printf("father is %d\n",id);
	}
	else
	{
		perror("fork");
		exit(-1);
	}
	return 0;
}
```

输出：

child 

father is 20503



例子2：不阻塞，为任意子进程收尸

```
#include "apue.h"

int main()
{
	pid_t id = fork();
	if(0 == id)
	{
		printf("child\n");
	}
	else if(id >0)
	{
		waitpid(-1,NULL,WNOHANG);
		printf("father is %d\n",id);
	}
	else
	{
		perror("fork");
		exit(-1);
	}
	return 0;

}
```

输出：

father is 20503

child



## 二. 进程执行任务exec

**exec族函数：在本进程中加载另一个程序，并且从头开始执行。本进程会完全被新进程替换**

注意：在执行完毕后，除了**进程号没变**以外，其他内容都被替换掉了

应用:

1)本进程重生

2)通过fork创建新进程 让新进程执行其他任务—主要应用



### 1. execl

```
#include <unistd.h>

 int execl(const char *path, const char *arg, ...);

格式：execl(可执行文件的路径,可执行文件名称,参数1，参数2，参数3，….,NULL)

注意：可执行文件的路径必须是which后的结果：e.g. which ls
```

#### 例子1

```
which ls
```

```
int main()
{
	puts("come...");
	execl("/bin/ls","ls","-l",NULL);
	puts("go...");
}
```

输出：

come

which ls的结果

不输出go...



#### 例子2：执行已有任务

```
which touch
```

```
//touch.c
#include <unistd.h>

int main()
{
	execl("/usr/bin/touch","touch","a.txt",NULL);

}
```



#### 例子3：创建自定义任务

```
//task.c
#include "apue.h"

int main()
{
	printf("pid is %d\n",getpid());
}
```

`gcc -o task.c task`

```
//execl1.c
#include "apue.h"

int main()
{
	pid_t id = fork();
	if(id > 0)
	{
		puts("father");
		wait(NULL);
	}
	else if(id == 0)
	{
		puts("child");
		execl("./task","task", NULL);
		puts("hah");
	}	
	else
	{
		perror("fork");
		exit(-1);
	}
}
```

`gcc execl1.c -o execl1`

输出：

father

child

pid is 20615

**不输出hah**



### 2. execvp

```
int execvp(const char *file, char *const argv[]);

格式：execvp(可执行文件名,指针数组)
```



```
int main()
{
	char*cmd[] = {"ls", "-l",NULL};
	execvp("ls",cmd);
}
```





## 三. 守护进程

### 1. 相关概念

前台进程：依附终端，终端结束，进程结束

后台进程：不依附终端，自己独立存在

进程组：多个进程

会话：多个进程组



回顾：

父进程控制着终端，父进程结束，终端打印出开头的：

`linux@ubuntu: ~$`



### 2. 创建守护进程

步骤：

1. 创建子进程 父进程结束(init领养子进程)

   ```
   pid_t id = fork();
   if(id > 0)
   {
   	exit(0);
   }
   ```

2. 创建新会话，让子进程彻底脱离终端

   ```
   setsid();
   ```

3. 改变当前工作目录

   ```
   chdir("/tmp");
   ```

   等价于cd /tmp, touch a.log

4. 修改文件掩码

   ```
   umask(0)
   ```

5. 关闭所有可能打开的文件描述符

   ```
   int n = getdtablesize();
   for(int i = 0; i<n; i++)
   {
   	close(i);
   }
   ```

   

#### 例子：获取当前系统时间并写入

```
void myDaemon()
{
	//1. 创建子进程，父进程结束
	pid_t id = fork();
	if(id > 0)
	{
		exit(0);
	}
	//此时只有子进程
	
	//2. 创建新会话，子进程摆脱终端
	setsid();
	
	//3. 改变当前工作目录
	chdir("/tmp")
	
	umask(0);
	int n = getdtablesize();
    for(int i = 0; i<n; i++)
    {
        close(i);
    }
}

int main()
{
	myDaemon();
	FILE *fp = NULL;
	fp = fopen("time.log","a");
	time_t t;
	if(fp != NULL)
	{
		while(1)
		{
			t = time(NULL);
			fprintf(fp, "%s", ctime(&t));
			fflush(fp);
			sleep(1);
		}
	}
}
```

```
cat /tmp/time.log
```

要关闭整个进程需要：

```
ps aux
```

查看到./a.out的id后

```
kill id
```



## 四. 进程间通信

### 1. 概念

#### 1.1 为什么进程间需要通信

Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间 

所以**进程和进程之间不能相互访问，要交换数据必须通过内核**，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。



#### 1.2 传输方式

可以分为单工、半双工和全双工数据传输

 **单工**：单工（Simplex Communication）模式的数据传输是单向的。通信双方中，一方固定为发送端，一方则固定为接收端。

 信息只能沿一个方向传输，

  **半双工**：半双工通信使用同一根传输线，既可以发送数据又可以接收数据，但不能同时进行发送和接收。数据传输允许数据在两个方向上传输，

 但是，在任何时刻只能由其中的一方发送数据，另一方接收数据。

 **全双工**：全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力，



#### 1.3 异步同步

数据通信的**同步**：取数据的瞬间需要考虑发送端发送的频度 也就是当时发没发数据 如果没有发数据就取不到数据

  数据通信的**异步**：取数据的时候 不用考虑发送端发送数据的频度 时间间隔 自动就接收了



#### 1.4 进程间通信方式

传统的有：管道，信号

还有

  IPC 通信： 消息队列、共享内存、信号量

  BSD（加州大学伯克利分校的伯克利软件发布中心开发） ：套接字



### 2. 传统进程间通信方式

#### 2.1 管道

**管道是半双工的**，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

##### 2.1.1 匿名管道

```
原理: 实为内核使用环形队列机制，借助内核缓冲区(4k)实现
    特点：只能用于亲属进程（父子进程）间通信

  #include <unistd.h>

 int pipe(int pipefd[2]);

功能：创建管道  

将读端的文件描述符返回到pipefd[0] 

将写端文件描述符返回到pipefd[1] 

返回值：成功0 失败-1 
```



