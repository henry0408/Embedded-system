[(33条消息) LeetCode：数组刷题（17道经典题目）_数组题目_奋斗的西瓜瓜的博客-CSDN博客](https://blog.csdn.net/qq_37085158/article/details/123668574)

链表：

[(33条消息) 链表专题 c/c++实现 LeetCode例题讲解_c++链表例题_RanLZ的博客-CSDN博客](https://blog.csdn.net/RangeLZ/article/details/97272742)



[ACM金牌选手整理的【LeetCode刷题顺序】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388470520)



大O表示法：

### 常见的大O运行时间（从快到慢）

- O(㏒n) 对数时间 比如二分查找
- O(n) 线性时间 比如简单查找
- O(n*㏒n) 比如快速排序
- O(n²) 比如选择排序
- O(n！) 比如旅行者问题
- 

先说下定义O(log2n)与O（n)的区别

O(log2n)含义说明：

比如123456789，你要找2，首先查中间元素5，大于2，所以直接排除掉5右边的6789，然后在1234里继续二分查找。每次排除1/2的元素，所以是O(log2n)。

O（n)含义说明：

n是元素的个数，O（n)意味着你把每个元素都访问一遍，这样你当然可以找到要查找的数了。但是对于有序数组，没必要这样遍历整个数组。
————————————————
版权声明：本文为CSDN博主「chenwch」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/heihu_malice7/article/details/90042912





## 1.给定一个数，判断这个数是否在该二维数组中。

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序

Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 14, return true.
Given target = 20, return false.

```
#include <stdio.h>

int main()
{
    int arr[5][5] = 
    {
        {1,   4,  7, 11, 15},
        {2,   5,  8, 12, 19},
        {3,   6,  9, 16, 22},
        {10, 13, 14, 17, 24},
        {18, 21, 23, 26, 30}
    };

    int num = 14;

    int col = 4;
    int row = 0;

    while (row>=0 && row<=4 && col >=0 && col <=4)
    {
        printf("%d %d\n",row,col);
        //printf("%d\n",arr[row][col]);
        
        if(arr[row][col] > num)
        {
            --col;
        }
        if(arr[row][col] < num)
        {
            ++row;
        }
        if(arr[row][col] == num)
        {
            printf("%d\n",num);
            break;
        }
    }
}
```
方法2：变成一个数组，排序后用二分法

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int arr[5][5] = 
    {
        {1,   4,  7, 11, 15},
        {2,   5,  8, 12, 19},
        {3,   6,  9, 16, 22},
        {10, 13, 14, 17, 24},
        {18, 21, 23, 26, 30}
    };

    int target = 14;

    int new_arr[25];
    int *p = &arr[0][0];
    for(int i=0; i<25; i++)
    {
        new_arr[i] = *(p+i);
    }

    for(int i=0; i<25; i++)
    {
        printf("%d ",new_arr[i]);
    }

    for(int i = 0; i<25-1;i++)
    {
        for(int j=0; j<25-1-i; j++)
        {
            if(new_arr[j]>new_arr[j+1])
            {
                int swap = new_arr[j];
                new_arr[j] = new_arr[j+1];
                new_arr[j+1] = swap;
            }
        }
    }

    int left = 0;
    int right = 25-1;

    while(left<right)
    {
        int mid = (left+right)/2;
        printf("mid is %d\n",new_arr[mid]);

        if(new_arr[mid] > target)
        {
            right = mid-1;
        }
        else if(new_arr[mid] < target)
        {
            left = mid+1;
        }
        else
        {
            printf("Find! The val is %d\n",new_arr[mid]);
            exit(-1);
        }
    }
    printf("Not found\n");
}
```



## 2. 把一个字符串中所有的空格替换成%20

难点：一个字符换成三个字符

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * new_arr(char *arr)
{
    int len = strlen(arr);
    printf("length is %d\n",len);
    int count = 0;      //判断有几个空格

    for(int i=0; i<len; i++)
    {
        if(arr[i] == ' ')
        {
            count++;
        }
    }
    printf("%d\n",count);

    char *p = (char*)malloc(sizeof(char)*(count*2+len+1));
    int j = 0, k = 0;
    while(j<len)
    {
        if(arr[j] == ' ')
        {
            //printf("%d %d\n",j,k);
            p[k] = '%';
            p[k+1] = '2';
            p[k+2] = '0';
            k+=3;
            j++;
        }
        else
        {
            p[k] = arr[j];
            j++;
            k++;
        }
    }
    return p;
}

int main()
{
    char *ch = "a b c";
    //printf("The len is %d\n",strlen(ch));

    char *p = new_arr(ch);
    printf("%s\n",p);
}
```

## 3. 二分法查找数组中是否存在一个元素

```
/*二分法查找*/

/*给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。（假设 nums 中的所有元素是不重复的。）*/

#include <stdio.h>

int find_val(int*arr, int length, int num)
{
    // left, right, mid是index
    int left = 0;
    int right = length-1;
    int mid;
    while(right >= left)        //如果右侧的index=左侧的index，意味着到了最中间的元素
    {
        mid = (right+left)/2;
        if(arr[mid]>num)
        {
            right--;
        }
        else if (arr[mid]<num)
        {
            left++;
        }
        else
        {
            printf("Exist\n");
            return mid;
        }
    }
    printf("Not exist\n");
    return -1;
}

int main()
{
    int arr[5] = {1,5,9,34,50};
    printf("The index is %d\n",find_val(arr, 5, 34));

    return 0;
}
```

复杂度为什么是O(logn)?

答：称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数。

总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。 

最差情况：运行k次。由于n/2^k取整后>=1，即令n/2^k=1， 可得k=log2n,（是以2为底，n的对数），所以[时间复杂度](https://so.csdn.net/so/search?q=时间复杂度&spm=1001.2101.3001.7020)可以表示O()=O(logn)。



## 4. 在排序数组中输出元素第一次出现和结束的位置

给定一个按照**升序**排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

二分法，左右滑动指针，来找到符合题意的区间

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。



## 5. 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```



## 6. leetcode 88合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

```
#include <stdio.h>

void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int i=m-1;
    int j=n-1;
    int tail = m+n-1;
    
    while(i >= 0 || j >= 0)
    {
        if(nums1[i]>nums2[j])
        {
            nums1[tail] = nums1[i];
            tail--;
            i--;
        }
        else if(nums1[i]<=nums2[j])
        {
            nums1[tail] = nums2[j];
            tail--;
            j--;
        }
        else if(i <0)
        {
            nums1[tail] = nums2[j];
            tail--;
            j--;
        }
        else if(j<0)
        {
            nums1[tail] = nums1[i];
            tail--;
            i--;
        }
    }
}

int main()
{
    int nums1[6] = {1,2,3,0,0,0};
    int m = 3;
    int nums2[3] = {2,5,6};
    int n = 3;
    merge(nums1, 6, m, nums2, 3, n);
    for(int i = 0; i<6;i++)
    {
        printf("%d ",nums1[i]);
    }
    printf("\n");
    return 0;
}
```

思路：i，j表示两个数组最后一个元素的index，从后向前遍历。哪个大，把那个塞到nums1的最后的空的元素的位置（index = tail）

时间复杂度：O(m+n)O(m+n)O(m+n)。 指针移动单调递减，最多移动 m+nm+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)O(m+n)。

空间复杂度：O(1)O(1)O(1)。 直接对数组 nums1\textit{nums}_1nums 
1

  原地修改，不需要额外空间

作者：力扣官方题解
链接：https://leetcode.cn/problems/merge-sorted-array/solutions/666608/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 7. 找出数组中重复的数字

在一个长度为 n 的一维数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。找出数组中重复的元素并返回该元素，如果没有重复则返回-1

```
int findRepeatNumber(int*arr, int len)
{
	int i = 0;
	while(i<len)
	{
		if(arr[arr[i]] == arr[i])
		{
			return arr[i];
		}
		else
		{
			if(arr[i] == i)
            {
                i++;
                continue;
            }
            else
            {
            	int temp = arr[i];
            	arr[i] = arr[temp];
            	arr[temp] = temp;
            }
		}
	}
	printf("no repeated num\n");
	return -1;
}

int main()
{
    int arr[10] = {3,8,2,1,4,5,6,7,8,9};
    int ans;
    ans = findRepeatNumber(arr, 10);

    printf("%d\n", ans);

    return 0;
}
```

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230422123559035.png" alt="image-20230422123559035" style="zoom:40%;" />

## 8. 剑指offer11. lc 154. 旋转数组的最小数字

本题和「154. 寻找旋转排序数组中的最小值 II」完全相同，是「153. 寻找旋转排序数组中的最小值」的延伸。读者可以先尝试第 153 题，体会在旋转数组中进行二分查找的思路，再来尝试解决本题。

作者：力扣官方题解
链接：https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solutions/340801/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 **重复** 元素值的数组 `numbers` ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的**最小元素**。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一次旋转，该数组的最小值为 1。 

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

```
输入：numbers = [3,4,5,1,2]
输出：1
```

```
输入：numbers = [2,2,2,0,1]
输出：0
```

```
#include <stdio.h>

int minArray(int* nums, int numbersSize)
{
	int left = 0;
	int right = numbersSize-1;
	while (left<right)
	{
		int mid = (left+right)/2;
        printf("%d %d %d\n",mid, left, right);
		
		//注意：不存在numbers[left] < numbers[right]的情况
		if((right-left) == 1)
		{
			printf("*******\n");
            return nums[right];
		}
		else if(nums[mid]>=nums[left])      //注意：一定要写等于号，不然例子3会出问题
		{
			left = mid;
		}
		else if(nums[mid]<=nums[right])
		{
			right = mid;
		}
	}
}

int main()
{
	int arr[5] = {2,4,6,0,1};
	int ans = minArray(arr,5);
	printf("%d\n",ans);             //输出0

    int arr1[7] = {2,4,4,6,1,2,2};
	int ans1 = minArray(arr1,7);
	printf("%d\n",ans1);            //输出1

    int arr2[7] = {2,2,2,2,2,1,2};
	int ans2 = minArray(arr2,7);
	printf("%d\n",ans2);            //输出1
}
```



## 8.5 lc153. 寻找旋转排序数组中的最小值（上题简化）

[153. 寻找旋转排序数组中的最小值 - 力扣（Leetcode）](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solutions/698479/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-5irwp/)



## 9. leetcode19. 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

```
输入：head = [1], n = 1
输出：[]
```

```
输入：head = [1,2], n = 1
输出：[1]
```

#### 方法1：

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;

    struct ListNode* len = dummy;
    
    int length = 0;
    // while (head != NULL) {
    //     head = head->next;
    //     length ++;
    // }

    while(len->next != NULL)
    {
        length++;   
        len = len->next;  
    }

    printf("length is %d\n",length);
    
    struct ListNode* cur = dummy;
    for (int i = 0; i < length - n; ++i) {
        cur = cur->next;
    }
    cur->next = cur->next->next;
    struct ListNode* ans = dummy->next;
    free(dummy);
    return ans;

}
```



步骤：先计算出链表长度，链表长度减去n即为要删除的元素的前一个元素

采用哨兵节点：原因是如果删除的元素是头节点的话，会方便操作



链表长度计算：两种选其一：注意不能用dummy节点，让dummy节点固定在head的前面

```
// while (head != NULL) {
//     head = head->next;
//     length ++;
// }

while(len->next != NULL)
{
    length++;   
    len = len->next;  
}
```



#### 方法2：

双指针，fast和slow之间隔了n个时，同时开始遍历，知道fast指向NULL（最后一个元素的下一个）。这样slow的下一个元素就是要删除的元素。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;

    struct ListNode* fast = dummy;
    struct ListNode* slow = dummy;

    for(int i = 0; i<n+1; i++)		//注意n+1
    {
        fast = fast->next;
    }

    while(fast != NULL)
    {
        fast = fast->next;
        slow = slow->next;
    }

    slow->next = slow->next->next;
    
    struct ListNode* ans = dummy->next;
    free(dummy);
    return ans;

}
```

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230424205827786.png" alt="image-20230424205827786" style="zoom:40%;" />

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230424205846322.png" alt="image-20230424205846322" style="zoom:35%;" />

## 10. leetcode 21. 合并两个有序链表

[21. 合并两个有序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

#### 方法1：双指针

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){
    struct ListNode* cur1 = list1;
    struct ListNode* cur2 = list2;

    struct ListNode* new_head = malloc(sizeof(struct ListNode));
    struct ListNode* pTail = new_head;

    while(1)
    {
        if(cur1 == NULL)
        {
            pTail->next = cur2;
            break;
        }
        if(cur2 == NULL)
        {
            pTail->next = cur1;
            break;
        }
        
        if(cur1->val < cur2->val)
        {
            pTail->next = cur1;
            cur1 = cur1->next;
            pTail = pTail->next;
        }
        else
        {
            pTail->next = cur2;
            cur2 = cur2->next;
            pTail = pTail->next;
        }

    }
    return new_head->next;
}
```



#### 方法2：递归

[21. 合并两个有序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/merge-two-sorted-lists/solutions/103891/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)



## 11. leetcode 876 链表的中间节点

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

[876. 链表的中间结点 - 力扣（Leetcode）](https://leetcode.cn/problems/middle-of-the-linked-list/)



```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* middleNode(struct ListNode* head){
    int length = 1;
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;
    struct ListNode* pNode = dummy;

    struct ListNode* pLen = head;
    if(head == NULL)
    {
        return NULL;
    }
    while(pLen != NULL)
    {
        length++;
        pLen = pLen->next;
    }
    length--;
    printf("The length is %d\n",length);

    int mid;
    mid = length/2;
    
    printf("The mid is%d\n",mid);

    for(int i = 0; i<= mid; i++)
    {
        pNode = pNode->next;
    }
    printf("The val is %d\n",pNode->val);

    return pNode;

}
```



## 12. leetcode 83. 删除排序链表中的重复元素

[83. 删除排序链表中的重复元素 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)



关键点：重复的元素在链表中出现的位置是连续的！！！所以判断pNode->next->next和pNode->next即可

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* deleteDuplicates(struct ListNode* head){
    struct ListNode* dummy = malloc(sizeof(struct ListNode));
    dummy->next = head;
    struct ListNode* pNode = dummy;
    // if (!head || !(head->next))
    //     return head;
    if(dummy->next == NULL)
    {
        return dummy->next;
    }

    while(pNode->next->next != NULL)
    {
        //printf("%d ",pNode->next->val);
        //pNode = pNode->next;
        
        if(pNode->next->val ==  pNode->next->next->val)
        {
            pNode->next = pNode->next->next;
        }
        else
        {
            pNode = pNode->next;
        }
    }
    return dummy->next;
}
```

注意加上第一个`dummy->next == NULL`判断：[83. 删除排序链表中的重复元素 - 力扣（Leetcode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solutions/2229939/shan-chu-lian-biao-xiang-tong-jie-dian-b-8811/)



## 13. leetcode20. 有效的括号

[20. 有效的括号 - 力扣（Leetcode）](https://leetcode.cn/problems/valid-parentheses/description/)

方法：改变方向后入栈，如果一样则出栈；最后如果栈空，则表示都匹配成功

```
bool isValid(char * s){
    int length = strlen(s);
    char *a = malloc(sizeof(char)*length+1);

    char t;
    int i=0,top=0;
    while(s[i]!='\0'){
        if(s[i]=='('||s[i]=='{'||s[i]=='['){
            if(s[i]=='(') t=')';
            if(s[i]=='{') t='}';
            if(s[i]=='[') t=']';
            top++;
            a[top]=t;
        }   
        else{
            if(a[top]!=s[i])
                return false;
            else
                top--;
        }  
        i++;
    }
    if(top==0)
        return true;
    else
        return false;

}
```

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230425162804480.png" alt="image-20230425162804480" style="zoom:25%;" />



## 14. leetcode234. 回文链表

[234. 回文链表 - 力扣（Leetcode）](https://leetcode.cn/problems/palindrome-linked-list/)

方法：

创建一个栈，把所有的数都存进去

依次出栈（相当于从后往前遍历），同时进行链表遍历（相当于从前向后遍历）。如果每一个元素都相等，说明为回文；有一个不等，说明不是回文。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool isPalindrome(struct ListNode* head){
    struct ListNode* pNode = head;
    struct ListNode* pTra = head;
    struct ListNode* pVal = head;

    int length = 0;
    while(pNode != NULL)
    {
        length++;
        pNode = pNode->next;
    }
    printf("length is %d\n",length);

    //创建空栈
    int *p = malloc(sizeof(int)*length);
    int top;
    for(top = 0; top<length; top++)
    {
        p[top] = pTra->val;
        pTra = pTra->next;
    }
    top = top-1;
    
    printf("top is %d\n",top);

    for(int j = 0; j<=top;j++)
    {
        printf("%d ",p[j]);
    }
    printf("\n");

    while(top>=0)
    {
        printf("%d %d\n",pVal->val, p[top]);
        if(pVal->val == p[top])
        {
            pVal = pVal->next;
            top--;
        }
        else
        {
            return false;
        }
    }
    return true;
    
}
```

参考[234. 回文链表 - 力扣（Leetcode）](https://leetcode.cn/problems/palindrome-linked-list/solutions/457312/di-gui-zhan-deng-3chong-jie-jue-fang-shi-zui-hao-d/)



## 15. leetcode1700. 无法吃午餐的学生数量

[1700. 无法吃午餐的学生数量 - 力扣（Leetcode）](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/description/)

注意：

1. 无法通过判断学生数组中1和0的数量与三明治数组中1和0的数量是否相等来判断是否都可以被拿走

2. 不需要考虑学生的出栈入栈，因为早晚都会循环一次，所以统计数量即可

   

我们只需要记录队列剩余的学生中 s0 和 s1的值

我们对整个过程进行模拟，如果栈顶的元素为 0，并且s0>0，我们将s0-1

如果栈顶的元素为 1 并且 s1>0，我们将 s1-1；否则终止过程，并返回 s0+s1 

```
int countStudents(int* students, int studentsSize, int* sandwiches, int sandwichesSize){
    int s1 = 0;     //喜欢方形的学生个数
    int s0 = 0;     //喜欢圆形的学生个数

    for (int i = 0; i<studentsSize; i++)
    {
        if(students[i] == 1)
            s1++;
        else
            s0++;
    }

    for(int j = 0; j<sandwichesSize;j++)	//遍历这个栈（相当于从栈顶依次取出元素）
    {
        if(sandwiches[j] == 0 && s0 >0)		//如果栈顶元素是0，且有同学要0
        {
            s0--;
        }
        else if(sandwiches[j] == 1 && s1>0)	//如果栈顶元素是1，且有同学要1
        {
            s1--;
        }
        //如果栈顶的元素没有任何同学要，则剩下的同学都拿不到，跳出循环
        else								
        {
            break;
        }
    }

    return s0+s1;
}
```



## 16. leetcode3. 无重复字符的最长子串

[3. 无重复字符的最长子串 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)



```
```





参考：[3. 无重复字符的最长子串 - 力扣（Leetcode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/41673/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-cshi-xian-/)



## 17. 剑指 Offer 09. 用两个栈实现队列

[剑指 Offer 09. 用两个栈实现队列 - 力扣（Leetcode）](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/description/)

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230430103325497.png" alt="image-20230430103325497" style="zoom:40%;" />

```
#define MAX_QUEUE_SIZE 10000

typedef struct {
    int *stackA;//这个用来进栈,入栈就是把value值复制到栈A中然后topA++;
    int *stackB;//这个用来出栈，出栈的是把A中的元素复制到B栈中然后topB--;
    int topA;
    int topB;
} CQueue;


CQueue* cQueueCreate() {
    CQueue *cq = malloc(sizeof(CQueue));
    if(cq == NULL)
    {
        free(cq);
        return NULL;
    }
    cq->stackA = malloc(sizeof(int)*MAX_QUEUE_SIZE);
    if(cq->stackA == NULL)
    {
        free(cq);
        return NULL;
    }
    cq->topA=-1;

    cq->stackB = malloc(sizeof(int)*MAX_QUEUE_SIZE);
    if(cq->stackB == NULL)
    {
        free(cq->stackA);
        free(cq);
        return NULL;
    }
    cq->topB=-1;

    return cq;
}

void cQueueAppendTail(CQueue* obj, int value) {
    if(obj->topA != MAX_QUEUE_SIZE){
        obj->topA++;
        obj->stackA[obj->topA] = value;
    }
}

int cQueueDeleteHead(CQueue* obj) {
    if(obj->topB != -1)
    {
        int num = obj->stackB[obj->topB];
        obj->topB--;
        return num;
    }
    else if(obj->topB == -1 && obj->topA != -1)
    {
        while(obj->topA != -1)
        {
            int num = obj->stackA[obj->topA];
            obj->topB++;
            obj->stackB[obj->topB] = num;
            obj->topA--;
        }
        int topBEelm = obj->stackB[obj->topB--];
        return topBEelm;
    }
    else
    {
        return -1;
    }
}

void cQueueFree(CQueue* obj) {
    if (obj != NULL) {
        if (obj->stackA != NULL) { free(obj->stackA); }
        if (obj->stackB != NULL) { free(obj->stackB); }
        free(obj);
    }
}

/**
 * Your CQueue struct will be instantiated and called as such:
 * CQueue* obj = cQueueCreate();
 * cQueueAppendTail(obj, value);
 
 * int param_2 = cQueueDeleteHead(obj);
 
 * cQueueFree(obj);
*/
```



## 18. 剑指 Offer 06. 从尾到头打印链表

[剑指 Offer 06. 从尾到头打印链表 - 力扣（Leetcode）](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/)

方法：存到一个栈（数组）里，数组反转后输出

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* reversePrint(struct ListNode* head, int* returnSize){
    int length = 10000;
    int *stack = (int*)malloc(sizeof(int)*length);

    struct ListNode* pnode = head;
    
    int i = 0;
    while(pnode != NULL)
    {
        stack[i] = pnode->val;
        pnode = pnode->next;
        i++;
    }

    *returnSize = i;

    for(int z = 0; z<i; z++)
    {
        printf("%d ",stack[z]);
    }
    printf("\n");

    printf("i is %d\n",i);

    for(int j = 0; j< i/2; j++)
    {
        int swap = stack[j];
        stack[j] = stack[i-j-1];
        stack[i-j-1] = swap;
    }

    for(int z = 0; z<i; z++)
    {
        printf("%d ",stack[z]);
    }
    printf("\n");
    return stack;
}
```



## 19.斐波那契数列

方法1：递归（会超出时间限制）

```
int fib(int n){
    if (n == 0)
    {
        return 0;
    }
    if(n == 1)
    {
        return 1;
    }
    else
    {
        return fib(n-1)+fib(n-2);
    }
}
```

方法2：数组,num1和num2分别为输出项的前两项

```
int fib(int n){
    const int MOD = 1000000007;
    if(n == 0)
        return 0;
    else if(n==1)
        return 1;

    int num1 = 0;
    int num2 = 1;
    int sum;

    for(int i = 2; i<=n; i++)
    {
        sum = (num1+num2)%MOD;
        
        num1 = num2;
        num2 = sum;

    }
    return sum;
}
```

同理青蛙跳台阶问题（青蛙一次可以上1或2级台阶，上n级台阶有多少种跳法），也是斐波那契数列



## 20. 剑指 Offer 15. 二进制中1的个数

[剑指 Offer 15. 二进制中1的个数 - 力扣（Leetcode）](https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/description/)

注意：不能盲目右移，要考虑负数的问题

比如0x80000000右移一位时，不能简单变成0x40000000，而是0xC0000000。这是因为移动之前是一个负数，所以符号位保持1不变。所以如果一直移动，最后变成0xFFFFFFFF，会陷入死循环。

回顾：c语言中数字怎么保存的：是以**补码**的形式存储的

十进制的5（32位）

```
00000000 00000000 00000000 00000101
```

原码：

一个正数，按照绝对值大小转换成的二进制数；

一个负数按照绝对值大小转换成的二进制数，然后最高位补1。

```
00000000 00000000 00000000 00000101		//5的原码
10000000 00000000 00000000 00000101		//-5的原码
```

反码：

正数的反码***与原码相同***

负数的反码为对该数的原码除符号位外各位取反

```
00000000 00000000 00000000 00000101		//5的反码
11111111 11111111 11111111 11111010		//-5的反码
```

补码

正数的补码与原码相同

负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1

```
00000000 00000000 00000000 00000101		//5的补码
11111111 11111111 11111111 11111011		//-5的补码
```

所以，-5在计算机中表达为：11111111 11111111 11111111 11111011。十六进制为0xFFFFFFFB



方法1： 先把n与1按位与，接着1不断左移一位，再与n按位与，相当于判断每一位

```
int hammingWeight(uint32_t n) {
    int count = 0;
    unsigned int flag = 1;
    while(flag != 0)
    {
        printf("%d\n",n & flag);
        if((n & flag)!= 0)
            count++;
        flag = flag << 1;
        //printf("%d\n",flag);
    }
    return count;
}
```

1最后会变成0（由于位数超过4字节）。



方法2：(n-1) & n

(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。
n&(n−1)解析： 二进制数字 n最右边的 1变成 0 ，其余不变。

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230501224135162.png" alt="image-20230501224135162" style="zoom:33%;" /><img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230501224212469.png" alt="image-20230501224212469" style="zoom:33%;" />

```
int hammingWeight(uint32_t n) {
    int count = 0;
    
    while(n)
    {
        ++count;
        n = (n-1) & n;
    }
    return count;
}
```



## 19. leetcode 94. 二叉树的中序遍历

[94. 二叉树的中序遍历 - 力扣（Leetcode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

void inorder(struct TreeNode* root, int* res, int* resSize) {
    if(root == NULL)
    {
        return;
    }
    inorder(root->left, res, resSize);
    res[*resSize] = root->val;
    (*resSize)++;
    inorder(root->right, res, resSize);
}

int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int *res = malloc(sizeof(int)*100);
    * returnSize = 0;
    inorder(root, res, returnSize);

    return res;
}
```

