# 线程

为什么有了进程还要引入线程？

## 1. 概念

1)**轻量级的进程** 也有pcb(进程控制块)但没有独立的地址空间(共享) 

应用层  进程 线程

2)**是系统调度的最小单位** 由进程创建 多个线程共享进程资源 **每个线程有唯一的标识 tid** 

主线程：main开始运行的线程  



## 2. 特点

1）**进程可以创建线程 多个线程共享进程资源** **进程结束 线程一定结束** 

2）不同线程 完成不同任务 共同为进程服务

3）一个进程的多个线程共享以下资源:静态数据 进程中打开的文件描述符 当前工作目录 

4）线程使用时 需要加载第三方的库  编译 -pthread  

5）**线程执行的先后顺序不确定 通过sleep控制**



**注意编译：gcc pthread.c -pthread** 



## 3. 函数

| 作用   | 进程函数 | 线程函数       |
| ------ | -------- | -------------- |
| 创建   | fork     | pthread_create |
| 退出   | exit     | pthread_exit   |
| 阻塞   | wait     | pthread_join   |
| 获取id | getpid   | pthread_self   |

​    

### 3.1 创建子线程: pthread_create()

```
  #include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);

​    Compile and link with -pthread.


不能用perror错误处理 strerror(ret)
    功能：创建线程 

//参数：

​      thread：线程ID号 

​      attr:线程属性 NULL 表示默认 

​      start_routine:线程处理函数

​      arg:传递给线程处理函数的参数

//返回值：成功返回0 失败-1   
```

#### 例子1：主线程为子线程传参

```
#include "apue.h"

void * pthread_fun(void *p)
{
	printf("%d\n", *(int*)p);
}

int main()
{
	int a = 666;
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, &a);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	printf("hello\n");
}
```

**注意：pthread_fun()函数中，要为传进去的p强转类型。**

输出：

```
hello
666
```

（顺序不固定）



#### 例子2：主/子线程结束顺序

```
#include "apue.h"

void * pthread_fun(void *p)
{
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
}
```

输出：

```
*.*.
```

原因：进程（主线程）结束，子线程也会结束。所以不会输出5个*



改进：主线程为子线程收尸



#### 例子3：线程返回值

```
#include "apue.h"

void *pthread_fun(void *)
{
	return (void*)0x8888;
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	
	void *value = NULL;
	pthread_join(tid, &value);
	printf("%p\n",value);		//0x8888
}
```





### 3.2 阻塞收尸: pthread_join()

```
#include <pthread.h> 

int pthread_join(pthread_t thread, void **retval); 

​    Compile and link with -pthread.

​    功能：以阻塞形式等待指定线程

//参数
1. 线程id号
2. NULL

​    返回值：成功返回0 失败-1 
```

```
#include "apue.h"

void * pthread_fun(void *p)
{
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
	pthread_join(tid, NULL);
}
```

输出：

```
*.*.***
```



### 3.3 获取线程ID号: pthread_self()

```
#include "apue.h"

void * pthread_fun(void *p)
{
	printf("pthread_fun: %lu\n",pthread_self());
	int i;
	for(i = 0; i<5; i++)
	{
		write(1, "*", 1);		//向标准输出（1）写一个字节的'*'
		sleep(1);				//每隔一秒
	}
}

int main()
{
	printf("main start: %lu\n",pthread_self());
	pthread_t tid;
	int ret = pthread_create(&tid, NULL, pthread_fun, NULL);
	if(ret < 0)
	{
		printf("%s\n",streooro(ret));
		exit(-1);
	}
	int i;
	for(i = 0; i<2; i++)
	{
		sleep(1);
		write(1,".",1);
	}
	pthread_join(tid, NULL);
	printf("main end: %lu\n",pthread_self());
}
```

发现：

只有pthread_fun函数中是子线程，其他都是主线程



### 3.4 进程的全局变量是线程的全局变量(共享的)：

与进程不同，线程之间共享全局变量

例子：创建两个子线程，交替打印"i am thread1...." "i am thread2..."

```
#include "apue.h"

int flag = 0;
void* pthread _fun1(void* p)
{
	while(1)
	{
		if(0 == flag)
		{
			puts("i am thread1");
			flag = 1;
		}
		sleep(1);
	}
}

void* pthread_fun2(void* p)
{
	while(1)
	{
		if(1 == flag)
		{
			puts("i am thread2");
			flag = 0;
		}
		sleep(1);
	}
}

int main()
{
	pthread tid1, tid2;
	int ret1 = pthread_create(&tid1, NULL, pthread_fun1, NULL);
	if(ret1<0)
	{
		printf("%s\n",strerror(ret1));
		exit(-1);
	}
	int ret2 = pthread_create(&tid2, NULL, pthread_fun2, NULL);
	if(ret2<0)
	{
		printf("%s\n",strerror(ret2));
		exit(-1);
	}
	
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
}
```



## 4. 线程同步与互斥

### 4.1 概念

#### 1）互斥

**互斥**：指某一资源同时只允许一个访问者对其进行访问 具有唯一性和排他性

​    但互斥无法限制访问者对资源的访问顺序 访问是无序 

线程互斥：相互线程间是互斥访问  目的是保证共享数据操作的完整性



**临界资源：** 是指在同一个时刻只允许有限个任务可以访问或修改的资源，通常包括硬件资源（CPU、内存、外设等）和软件资源（共享代码段、共享结构、变量等）



**什么是临界区？**
进程中访问临界资源的 那段程序代码 称为临界区

 

互斥锁 

条件变量

 

#### 2）同步

**同步**: 同步即协同步调，按预定的先后次序运行 在互斥基础上 通过其他机制实现 访问者对资源有序访问 

线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。

信号量



### 4.2 线程同步（信号量）

#### 4.2.1 信号量值-1：sem_wait()

```
#include <semaphore.h>
    
int sem_wait(sem_t *sem);
```



#### 4.2.2 信号量值+1：sem_post()

```
 #include <semaphore.h>

int sem_post(sem_t *sem);
```



#### 4.2.3 初始化一个信号量的值为value：sem_init()

```
 #include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);

​    功能：初始化一个信号量的值为value 

//参数： 

​    sem ：信号量 

​    pshared：是否在进程间使用 一般是0 表示不在进程间使用 

​    value ：信号量的值   

//返回值：成功返回0 失败-1 
```



#### 4.2.4 销毁一个信号量：sem_destroy()

```
int sem_destroy(sem_t *sem);
```



#### 例子

````
#include "apue.h"

sem_t s;
void* pthread_fun1(void* p)
{
	sleep(3);
	puts("i am fun...");
	sem_post(&s);
}

void* pthread_fun2(void* p)
{
	sem_wait(&s);	
	puts("i am fun 1...");
	
}

int main()
{
	pthread_t tid1, tid2;
	
	sem_init(&s,0,0);
	
	int ret1 = pthread_create(&tid1, NULL, pthread_fun1, NULL);
	if(ret1<0)
	{
		printf("%s\n",strerror(ret1));
		exit(-1);
	}
	int ret2 = pthread_create(&tid2, NULL, pthread_fun2, NULL);
	if(ret2<0)
	{
		printf("%s\n",strerror(ret2));
		exit(-1);
	}
	
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	
	sem_destroy(&s);
}
````



### 4.3 互斥

试衣间问题：



#### 4.3.1 互斥量(锁)mutex

Linux中提供一把互斥锁，每个线程在操作资源之前都先尝试加锁，如果加锁成功，才能操作，操作结束后解锁。



**注意：**之前的信号量是给对方放行



资源还是共享的，线程之间还是竞争的，但是“锁”把资源的访问变成互斥操作

**作用：**保护临界资源

同一时刻，只有一个线程能持有锁



#### 4.3.2 函数

```
pthread_mutex_t	//互斥锁结构体
pthread_mutex_t m;	//定义一把锁
pthread_mutex_init(&m,NULL);	//初始化锁
pthread_mutex_lock(&m);		//加锁，如果不成功，则阻塞
pthread_mutex_unlock(&m);	//解锁
pthread_mutex_destroy(pthread_mutex_t *m);	//销毁互斥锁
```



例子：

```
#include "apue.h"

//1. 定义锁
pthread_mutex_t m;

void *pthread_fun(void* p)
{
	int i;
	//3. 加锁
	pthread_mutex_lock(&m);
	for(i = 0; i<3; i++)
	{
		printf("%lu\n",pthread_self());		//查看哪个线程在用
		sleep(1);	//本线程睡眠，其他线程可能占用，所以要用锁
	}
}

int main()
{
	//创建三个线程
	pthread_t tid[3];
	
	//2. 初始化锁
	pthread_mutex_init(&m, NULL);
	
	int i;
	for(i = 0; i<3; i++)
	{
		pthread_create(&tid[i],NULL,pthread_fun,NULL);
	}
	
	//收尸
	for(i = 0; i<3; i++)
	{
		pthread_join(tid[i],NULL);
	}
	
	//销毁锁
	pthread_mutex_destroy(&m);
}
```



### 4.4 条件变量（未完）

不是锁，但能阻塞线程（负责引起阻塞）



**使用**：条件变量+锁

加锁后，只有满足条件，才能做任务



#### 4.4.1 函数

```
条件变量类型：pthread_cond_t
定义条件变量：pthread_cond_t c;
```

```
初始化条件变量：（两种方法）：

方法1：
int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
参2：attr表条件变量属性，通常为默认值，传NULL即可

方法2：静态初始化
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
```

```
销毁条件变量
int pthread_cond_destroy(pthread_cond_t *cond);//销毁条件变量
```





```
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
//1)
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;/*静态初始化互斥锁*/
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;/*初始化条件变量*/
int i=1;

//输出非3的倍数
void *thread1(void *junk)
{
	for(i=1;i<=9;i++)
	{
		pthread_mutex_lock(&mutex);/*锁住互斥量*/
		if(i%3==0)
		{
			pthread_cond_signal(&cond);/*条件改变，发送信号，通知thread2*/
			printf("已唤醒thread2\n");
		}
		else
		{
			printf("thread1:%d\n",i);//1 2 4 5 7 8
		}
		pthread_mutex_unlock(&mutex);/*解锁互斥量*/
		sleep(1);
	}
}

//输出3的倍数
void *thread2(void *junk)
{
	while(i<9)
	{
		pthread_mutex_lock(&mutex);
		if(i%3!=0)
		{
			printf("thread2 开始开始等待\n");
			pthread_cond_wait(&cond,&mutex);/// 解锁-》阻塞等待--被唤醒--》上锁
				printf("thread2 结束等待\n");
			printf("thread2:%d\n",i);//3 6 9
		}
		pthread_mutex_unlock(&mutex);
	sleep(1);
	}
}

int main()
{
	pthread_t t_a;
	pthread_t t_b;
	pthread_create(&t_a,NULL,thread1,NULL);/*创建进程t_a*/
	pthread_create(&t_b,NULL,thread2,NULL); /*创建进程t_b*/

	pthread_join(t_a, NULL);/*等待进程t_a结束*/
	pthread_join(t_b, NULL);/*等待进程t_b结束*/
	pthread_mutex_destroy(&mutex);
	pthread_cond_destroy(&cond);	
	return 0;
}

```



## 5. 死锁

### 5.1 什么是死锁？

概念： 多个并发进程因争夺系统资源而产生相互等待的现象。
多个进程可能竞争资源 某个进程申请资源 但这个资源不可用 此时进程进入等待状态 
如果所申请资源被其他等待进程占有 那么该进程可能也无法改变其状态 就会一直等 这种情况是死锁

 

### 5.2 死锁产生的原因：

• 　　系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
• 　　进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。



### 5.3 产生死锁的四个必要条件

　　**互斥条件**：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
　　
   **请求与保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

　　**不可剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

　　**循环等待条件**：若干进程间形成首尾相接循环等待资源的关系。

　　这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

 

### 5.4 避免死锁的方法

　死锁避免的基本思想：系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配，这是一种保证系统不进入死锁状态的动态策略。

　　如何避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。

 一般来说互斥条件是无法破坏的，所以在预防死锁时主要从其他三个方面入手：
　　**(1)****破坏请求和保持条件**：在系统中不允许进程在已获得某种资源的情况下，申请其他资源，即要想出一个办法，阻止进程在持有资源的同时申请其它资源。
　　　　方法一：**在所有进程开始运行之前，必须一次性的申请其在整个运行过程中所需的全部资源，这样，该进程在整个运行期间便不会再提出资源请求****，**从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的需要，即使其它所需的各资源都空闲也不分配给该进程，而让该进程等待，由于该进程在等待期间未占用任何资源，于是破坏了“保持”条件。
　　　　**方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源时，需要先把它先前占有的资源释放掉，然后才能提出对资源的申请
　　　　两种协议比较：第二种协议优于第一种协议，因为第一种协议会造成资源的严重浪费，使资源利用率大大的降低，也会由于占据大量资源导致其它进程的饥饿问题。

　　(2）破坏不可抢占条件（允许对资源实行抢夺）
　　　**方式一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源**，如果有必要，可再次请求这些资源和另外的资源。
　　　　**方式二：如果一个进程请求当前被另一个进程占有的资源，则操作系统可以抢占另一个进程，要求它释放资源**，只有在任意两个进程的优先级都不相同的条件下，该方法才能预防死锁。

　　(3)破坏循环等待条件
　对系统所有资源进行线性排序并赋予不同的序号，这样我们便可以规定进程在申请资源时必须按照序号递增的顺序进行资源的申请，当以后要申请时需检查要申请的资源的编号大于当前编号时，才能进行申请。



## 6. 服务器

### 6.1 服务器模型

服务器数目至少 一个或多个 代码大 处理客户端请求 

客户端数目多 代码少  向服务器发请求 

#### TCP循环服务器

同一时刻 只能响应一个客户端请求 依次处理每个客户端 后边的客户端必须等待前面的处理完 效率低 等待时间长 

#### TCP并发服务器

同一时刻 能响应多个客户端请求 同时处理多客户端 创建进程或线程 让新进程或线程处理客户端 原来进程负责连接客户端 效率高 



### 6.2 并发服务器：多进程并发

一个售票口当作服务台，每当有一个顾客，该服务台负责创建一个新的售票口给顾客服务。

也就是说，服务器的父进程中，每当有一个客户端连接，就创建一个子进程服务于客户端。

#### 6.2.1 实现多进程并发回射服务器

server.c

```
#include"apue.h"

//处理客户端
void deal_client(int newconfd)
{
	//回射
	char buf[100]="\0";
	ssize_t ret_read;
	int i;

	for(i=0;i<3;i++)
	{
		//从套接字读取数据
		ret_read = read(newconfd,buf,sizeof(buf));

		//将数据写回客户端
		write(newconfd,buf,ret_read);

		bzero(buf,sizeof(buf));
	}

}
int main()
{
	//1.创建套接字
	int listenfd = socket(AF_INET,SOCK_STREAM,0);
	if(listenfd<0)
	{
		perror("socket");
		exit(-1);
	}

	//2.绑定 套接字+本机地址信息
	struct sockaddr_in self_addr;
	self_addr.sin_family = AF_INET;
	self_addr.sin_port = htons(5678);
	self_addr.sin_addr.s_addr = inet_addr("192.168.126.136");
	int ret = bind(listenfd,(struct sockaddr*)&self_addr,sizeof(self_addr));
	if(ret<0)
	{
		perror("bind");
		close(listenfd);
		exit(-1);
	}

	//3.监听 设置最大连接数 参数2：最大连接数
	int ret_listen = listen(listenfd,10);
	if(ret_listen<0)
	{
		perror("listen");
		close(listenfd);
		exit(-1);

	}

	//4.阻塞等待连接
	int newconfd;
	pid_t id;
	while(1)
	{
		//连接客户端
		newconfd= accept(listenfd,NULL,NULL);
		if(newconfd<0)
		{
			perror("accept");
			close(listenfd);
			exit(-1);

		}

		//创建子进程
		id = fork();
		if(0==id)//子
		{
			//处理客户端请求
			deal_client(newconfd);
		}

	}
}
```

client.c

```
#include"apue.h"

int main()
{
	//1.创建套接字
	int sockfd = socket(AF_INET,SOCK_STREAM,0);
	if(sockfd<0)
	{
		perror("socket");
		exit(-1);
	}

	struct sockaddr_in server_addr;//服务器端地址信息
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(5678);
	server_addr.sin_addr.s_addr = inet_addr("192.168.126.136");

	//2.发起三次握手连接请求
	//参数1：套接字
	//参数2：服务器端地址信息
	//参数3：服务器端地址信息长度
	//这个函数成功返回 标志3次握手完成
	int ret = connect(sockfd,(struct sockaddr*)&server_addr,sizeof(server_addr));
	if(ret<0)
	{
		perror("connect");
		close(sockfd);
		exit(-1);
	}

	char buf[100]="\0";
	int i;
	//3.读写数据
	for(i=0;i<3;i++)
	{
		//键盘获取数据 写给服务器
		gets(buf);
		write(sockfd,buf,strlen(buf)+1);
		
		//从套接字获取数据写到屏幕
		read(sockfd,buf,sizeof(buf));
		puts(buf);

		bzero(buf,sizeof(buf));
	}
	//4.关闭套接字
	close(sockfd);
	return 0;
}
```

开启多个客户端，一个服务器



#### 6.2.2 缺点

\1. 父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符)

\2. 系统内创建进程个数(与内存大小相关)

\3. 进程创建过多是否降低整体服务性能(进程调度)



### 6.3 并发服务器：多线程并发

解决多进程资源消耗问题



注意：需要用到一个新的函数，负责让线程自动收尸。因为根据线程的特性，如果收尸函数放在主函数的循环中，会阻塞导致其他线程无法服务于客户端。

```
pthread_detach(pthread_self());//线程默认状态为结合的 将状态改为unjoinable(分离的)状态 子线程退出会自动释放资源
```



#### 练习1：多线程并发回射服务器

server.c

```
#include"apue.h"

void* deal_client(void *p)
{
	pthread_detach(pthread_self());//线程默认状态为结合的 将状态改为unjoinable(分离的)状态 子线程退出会自动释放资源
	
	int newconfd = *(int*)p;

	//回射
	char buf[100]="\0";
	ssize_t ret_read;
	int i;

	for(i=0;i<3;i++)
	{
		//从套接字读取数据
		ret_read = read(newconfd,buf,sizeof(buf));

		//将数据写回客户端
		write(newconfd,buf,ret_read);

		bzero(buf,sizeof(buf));
	}
		return NULL;
}
int main()
{
	//1.创建套接字
	int listenfd = socket(AF_INET,SOCK_STREAM,0);
	if(listenfd<0)
	{
		perror("socket");
		exit(-1);
	}

	//2.绑定 套接字+本机地址信息
	struct sockaddr_in self_addr;
	self_addr.sin_family = AF_INET;
	self_addr.sin_port = htons(5678);
	self_addr.sin_addr.s_addr = inet_addr("192.168.0.11");
	int ret = bind(listenfd,(struct sockaddr*)&self_addr,sizeof(self_addr));
	if(ret<0)
	{
		perror("bind");
		close(listenfd);
		exit(-1);
	}

	//3.监听 设置最大连接数 参数2：最大连接数
	int ret_listen = listen(listenfd,10);
	if(ret_listen<0)
	{
		perror("listen");
		close(listenfd);
		exit(-1);

	}

	//4.阻塞等待连接
	int newconfd;
	pthread_t tid;
	while(1)
	{
		//连接客户端
		newconfd= accept(listenfd,NULL,NULL);
		if(newconfd<0)
		{
			perror("accept");
			close(listenfd);
			exit(-1);

		}

		//创建子线程
		pthread_create(&tid,NULL,deal_client,&newconfd);

	}
}
```



client.c（与之前不变）

```
#include"apue.h"

int main()
{
	//1.创建套接字
	int sockfd = socket(AF_INET,SOCK_STREAM,0);
	if(sockfd<0)
	{
		perror("socket");
		exit(-1);
	}

	struct sockaddr_in server_addr;//服务器端地址信息
	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(5678);
	server_addr.sin_addr.s_addr = inet_addr("192.168.126.136");

	//2.发起三次握手连接请求
	//参数1：套接字
	//参数2：服务器端地址信息
	//参数3：服务器端地址信息长度
	//这个函数成功返回 标志3次握手完成
	int ret = connect(sockfd,(struct sockaddr*)&server_addr,sizeof(server_addr));
	if(ret<0)
	{
		perror("connect");
		close(sockfd);
		exit(-1);
	}

	char buf[100]="\0";
	int i;
	//3.读写数据
	for(i=0;i<3;i++)
	{
		//键盘获取数据 写给服务器
		gets(buf);
		write(sockfd,buf,strlen(buf)+1);
		
		//从套接字获取数据写到屏幕
		read(sockfd,buf,sizeof(buf));
		puts(buf);

		bzero(buf,sizeof(buf));
	}
	//4.关闭套接字
	close(sockfd);
	return 0;
}
```



#### 练习2：客户端发文件名，服务器读取文件数据发回给客户端（未完）

```

```







### 6.4 并发服务器：IO多路复用select

select并发服务器

```
1.3 select并发服务器—参考

//IO多路复用技术select函数的使用
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/select.h>

int main()
{
int i;//for循环的初始化
int n;//读取字节个数
int listenfd;//监听文件描述符
int cfd;//通讯文件描述符
int ret;
int nready;
int maxfd;//最大的文件描述符
char buf[FD_SETSIZE];
socklen_t len;
int maxIndex;//有效的文件描述符最大值
int connfd[FD_SETSIZE];//有效文件描述符数组(与客户端连接的套接字) 用数组 判断哪个客户端被激活时方便 如果用集合 将每个符取出来费劲
fd_set tmpfds,rdfds;//要监控的文件描述符集 rdfds 存储要检测的所有描述符 比用数组方便 tmpfds注册以及带回激活描述符
struct sockaddr_in svraddr,cliaddr;

//创建socket
listenfd = socket(AF_INET,SOCK_STREAM,0);
if(listenfd<0){
perror("socket error");
return -1;
}
//允许端口复用
int opt = 1;
setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(int));

//绑定
svraddr.sin_family = AF_INET;
svraddr.sin_port = htons(6789); 
svraddr.sin_addr.s_addr = htonl(INADDR_ANY);
ret = bind(listenfd,(struct sockaddr *)&svraddr,sizeof(struct sockaddr_in));
if(ret<0)
{
perror("bind error");
return -1;
}
//监听
ret = listen(listenfd,5);
if(ret<0){
perror("listen error");
return -1;
}

//文件描述符集初始化
FD_ZERO(&tmpfds);
FD_ZERO(&rdfds);

//将监听文件描述符加入到监控的读集合中
FD_SET(listenfd,&rdfds);

//初始化有效的文件描述符集，-1表示可用，该数组不保存listenfd
for(i=0;i<FD_SETSIZE;i++)
{
connfd[i] = -1;
}
maxfd = listenfd;
len = sizeof(struct sockaddr_in);
//将监听文件描述符listenfd加入到select监控中

while(1)
{
//select为阻塞函数，若没有变化的文件描述符，就一直阻塞，若有事件发生则解除阻塞，函数返回
//select的第二个参数tmpfds为输入输出参数，调用select完毕后这个节后中保留的是发生变化(激活)的文件描述符
tmpfds = rdfds;
nready = select(maxfd+1,&tmpfds,NULL,NULL,NULL);
if(nready>0)
{//文件描述符集有变化

//发生变化的文件描述符有两类，一类是监听类的，一类是用于客户端数据通信的。
//监听文件描述符有变化，有新的连接到来，则accept新的连接
if(FD_ISSET(listenfd,&tmpfds))
{
    cfd = accept(listenfd,(struct sockaddr *)&cliaddr,&len);
    if(cfd<0)
   {
       continue;
   }
    break;
 }

//先找到位置，然后将新的与客户端连接的文件描述符保存到connfd数组中
for(i=0;i<FD_SETSIZE;i++)
{
if(connfd[i]==-1)
{
connfd[i] = cfd;
break;
}
}
//若连接总数达到的最大值
if(i==FD_SETSIZE)
{
close(cfd);
printf("too many clients,i==[%d]\n",i);
continue;
}
//确保connfd中maxIndex保存的是最后一个文件描述符的下标
if(i>maxIndex)
{
maxIndex = i;
}
//打印客户端的IP和PORT
// char sIP[16];
// memset(sIP,0x00,sizeof(sIP));
// printf("receive from client ---->IP[%s],PORT=[%d]\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,sIP,sizeof(sIP)),htons(cliaddr.sin_port));

//将新的文件描述符加入到select监控的文件描述符中
FD_SET(cfd,&rdfds);

//更新最大描述符
if(maxfd<cfd)
{
maxfd = cfd;
}

//如果没有别的被激活的文件描述符，则无需执行后续代码
if(--nready<=0)//说明只有listenfd被激活了 
{
continue;
}
}

//下面是通信（与客户端连接的）文件描述符有变化的情况
//只需要循环connfd数组中有效的文件描述符即可，这样可以减少循环次数
for(i=0;i<=maxIndex;i++)
{
int sockfd = connfd[i];
//数组内的文件描述符如果被释放，有可能变为-1
if(sockfd==-1)
{
continue;
}

if(FD_ISSET(sockfd,&tmpfds))
{
memset(buf,0,sizeof(buf));
n = read(sockfd,buf,sizeof(buf));
if(n<0)//读数据出错 则关闭客户端套接字
{
perror("read over");
close(sockfd);
FD_CLR(sockfd,&rdfds);//释放关闭的套接字
connfd[i] = -1;//将connfd[0]置为-1，表示位置可用
}else if(n==0)//对方断开连接
{
printf("client is closed\n");
close(sockfd);
FD_CLR(sockfd,&rdfds);//释放套接字
connfd[i] = -1;//将connfd[0]置为-1，表示位置可用
}else
{
printf("[%d]:[%s]\n",n,buf);
write(sockfd,buf,n);//将数据写回客户端
}
if(--nready<=0)
{
break;//注意这里是break，而不是continue，应该是从最外层的while继续循环
}
}
}
}
}
//关闭监听文件描述符
close(listenfd);
return 0;
}
```

