[(33条消息) LeetCode：数组刷题（17道经典题目）_数组题目_奋斗的西瓜瓜的博客-CSDN博客](https://blog.csdn.net/qq_37085158/article/details/123668574)

链表：

[(33条消息) 链表专题 c/c++实现 LeetCode例题讲解_c++链表例题_RanLZ的博客-CSDN博客](https://blog.csdn.net/RangeLZ/article/details/97272742)



[ACM金牌选手整理的【LeetCode刷题顺序】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388470520)



大O表示法：

### 常见的大O运行时间（从快到慢）

- O(㏒n) 对数时间 比如二分查找
- O(n) 线性时间 比如简单查找
- O(n*㏒n) 比如快速排序
- O(n²) 比如选择排序
- O(n！) 比如旅行者问题
- 

先说下定义O(log2n)与O（n)的区别

O(log2n)含义说明：

比如123456789，你要找2，首先查中间元素5，大于2，所以直接排除掉5右边的6789，然后在1234里继续二分查找。每次排除1/2的元素，所以是O(log2n)。

O（n)含义说明：

n是元素的个数，O（n)意味着你把每个元素都访问一遍，这样你当然可以找到要查找的数了。但是对于有序数组，没必要这样遍历整个数组。
————————————————
版权声明：本文为CSDN博主「chenwch」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/heihu_malice7/article/details/90042912





## 1.给定一个数，判断这个数是否在该二维数组中。

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序

Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 14, return true.
Given target = 20, return false.

```
#include <stdio.h>

int main()
{
    int arr[5][5] = 
    {
        {1,   4,  7, 11, 15},
        {2,   5,  8, 12, 19},
        {3,   6,  9, 16, 22},
        {10, 13, 14, 17, 24},
        {18, 21, 23, 26, 30}
    };

    int num = 14;

    int col = 4;
    int row = 0;

    while (row>=0 && row<=4 && col >=0 && col <=4)
    {
        printf("%d %d\n",row,col);
        //printf("%d\n",arr[row][col]);
        
        if(arr[row][col] > num)
        {
            --col;
        }
        if(arr[row][col] < num)
        {
            ++row;
        }
        if(arr[row][col] == num)
        {
            printf("%d\n",num);
            break;
        }
    }
}
```
## 2. 把一个字符串中所有的空格替换成%20

难点：一个字符换成三个字符

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char * new_arr(char *arr)
{
    int len = strlen(arr);
    printf("length is %d\n",len);
    int count = 0;      //判断有几个空格

    for(int i=0; i<len; i++)
    {
        if(arr[i] == ' ')
        {
            count++;
        }
    }
    printf("%d\n",count);

    char *p = (char*)malloc(sizeof(char)*(count*2+len+1));
    int j = 0, k = 0;
    while(j<len)
    {
        if(arr[j] == ' ')
        {
            //printf("%d %d\n",j,k);
            p[k] = '%';
            p[k+1] = '2';
            p[k+2] = '0';
            k+=3;
            j++;
        }
        else
        {
            p[k] = arr[j];
            j++;
            k++;
        }
    }
    return p;
}

int main()
{
    char *ch = "a b c";
    //printf("The len is %d\n",strlen(ch));

    char *p = new_arr(ch);
    printf("%s\n",p);
}
```

## 3. 二分法查找数组中是否存在一个元素

```
/*二分法查找*/

/*给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。（假设 nums 中的所有元素是不重复的。）*/

#include <stdio.h>

int find_val(int*arr, int length, int num)
{
    // left, right, mid是index
    int left = 0;
    int right = length-1;
    int mid;
    while(right >= left)        //如果右侧的index=左侧的index，意味着到了最中间的元素
    {
        mid = (right+left)/2;
        if(arr[mid]>num)
        {
            right--;
        }
        else if (arr[mid]<num)
        {
            left++;
        }
        else
        {
            printf("Exist\n");
            return mid;
        }
    }
    printf("Not exist\n");
    return -1;
}

int main()
{
    int arr[5] = {1,5,9,34,50};
    printf("The index is %d\n",find_val(arr, 5, 34));

    return 0;
}
```

复杂度为什么是O(logn)?

答：称作折半查找（half-interval search），每次划分一半进行下一步搜索，所以时间复杂度无非就是while循环的次数。

总共有n个元素，每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。 

最差情况：运行k次。由于n/2^k取整后>=1，即令n/2^k=1， 可得k=log2n,（是以2为底，n的对数），所以[时间复杂度](https://so.csdn.net/so/search?q=时间复杂度&spm=1001.2101.3001.7020)可以表示O()=O(logn)。



## 4. 在排序数组中输出元素第一次出现和结束的位置

给定一个按照**升序**排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

二分法，左右滑动指针，来找到符合题意的区间

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。



