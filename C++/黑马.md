# 黑马

## 0. 补充内容

### 0.1 内存分区模型：

生命周期不同！

代码区：函数体的二进制代码

全局区：全局变量，静态变量（static），全局常量

栈区：（编译器自动分配和释放）函数参数（形参），局部变量

堆区：（程序员分配和释放，如不释放，程序结束时由操作系统释放）new关键字开辟



#### a. 程序运行前：

**生成exe，未执行程序前分成两个区域：******代码区和全局区****

代码区：存放CPU执行的机器指令（二进制）

代码区是共享的：对于频繁被执行的程序，只需要再内存中有一份代码即可

代码区是只读的：防止程序意外地修改了他的指令



全局区：存放全局变量和静态变量

全局区包含常量区：其中有字符串常量，其他常量（const修饰的常量）

全局区的数据在程序结束之后由操作系统进行释放



**const修饰的全局变量，const修饰的局部变量（全局常量和局部常量）：只要是局部，都不放在全局区**

![image-20230822192215118](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230822192215118.png)



#### b. 程序运行后

栈区：注意不要返回局部变量的地址

```
int* func()
{
	int a = 10;	//局部变量存在栈区，函数执行完毕后自动释放
	return &a;
}

int main()
{
	int *p = func();
	cout<< *p <<endl;	//10，有些编译器做了保留
	cout<< *p <<endl;	//随机数
}
```



#### c. new/delete操作符

 ```
#include <iostream>
using namespace std;

int* func()
{
	int* a = new int(10);
	return a;
}

int main()
{
	int* p = func();
	cout<< *p <<endl;
	delete p;
}
 ```

指针本质也是局部变量，指针在栈上，但是指针指向的数据是在堆区



```
void func()
{
	int* a = new int[10];	//创建长度为10的数组
	for(int i = 0; i<10; i++)
	{
		a[i] = i+100;
	}
	delete[] a;
}

int main()
{
	func();
}
```



### 0.2 new和delete

```
//申请空间
int* ptr = new int;

//申请空间并初始化
int* ptr2 = new int(1);
cout<<*ptr<<endl;		//1

//申请连续的空间，空间大小为4*10=40
int* arr = new int[10];//c++98不允许连续空间初始化

//释放单个空间
delete ptr;
delete ptr2;

//释放连续的多个空间
delete[] arr; 
```





### 0.3 引用

作用：给一个变量起别名

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230822200842354.png" alt="image-20230822200842354" style="zoom:60%;" />

```
int a = 10;
int& b = a;
cout<<a<<endl;	//10
cout<<b<<endl;	//10

b = 20;
cout<<a<<endl;	//20
cout<<b<<endl;	//20
```



引用必须初始化，且初始化后不可以再改变：

```
int a = 10;
int &b = a;	//必须初始化

int c = 20;
b = c;	//代码不报错，但是相当于赋值，而不是更改引用

cout<<a<<endl;	//20
cout<<b<<endl;	//20
cout<<c<<endl;	//20
```



引用做函数参数：简化指针

```
//交换函数

//1.值传递：形参不会修饰实参（a和b最后不会改变）
void swap1(int a, int b)
{
	int c = a;
	a = b;
	b = c;
}

//2.地址传递：a和b最后改变
void swap2(int* a, int* b)
{
	int c = *a;
	*a = *b;
	*b = c;
}

//3. 引用传递：
void swap3(int& a, int& b)
{
	int c = a;
	a = b;
	b = c;
}

int main()
{
	int a = 10;
	int b = 20;
	swap3(a, b);	//a = 20, b = 10
}
```



引用做函数返回值:

不要返回局部变量的引用

```
int& test1()
{
	int a = 10;	//局部变量，存在于栈区
	return a;
}
int main()
{
	int &ref = test1();
	cout<<ref<<endl;	//a的内存已经被释放，所以会报错
}
```

改正：

```
int& test2()
{
	static int a = 10;	//静态变量，存在于全局区
	return a;
}
int main()
{
	int &ref = test2();
	cout<<ref<<endl;	//不会报错
}
```



函数的调用可以作为左值：

```
int& test2()
{
	static int a = 10;	//静态变量，存在于全局区
	return a;
}
int main()
{
	int& ref =  test2();
	cout<<ref<<endl;	//10
	test2() = 1000;
	cout<<ref<<endl;	//1000
}
```



指针的本质：指针常量（指针的指向不可以改，指向的值可以改）

```
&a == int* const ref
```



```
int main()
{
	int a = 10;
	int& ref = a;	//给a起别名叫ref，相当于int* const ref = &a
	ref = 20;
	
	cout<<a<<" "<<ref<<endl;	//20 20
}
```



```
void func(int& ref)
{
	ref = 100;	//因为ref是引用，转换为*ref = 100
}

int main()
{
	int a = 10;
	int& ref = a;	//给a起别名叫ref，相当于int* const ref = &a
	func(a);
	
	cout<<a<<" "<<ref<<endl;	//100 100
}
```



常量引用

修饰形参，防止误操作：用const修饰

```
int & ref = 10;		//报错，必须引用一块合法的内存空间
```

```
const int& ref = 10;	//不报错，
//加上const之后，编译器将代码修改为int temp = 10; int& ref = temp
```



```
const int& ref = 10;
ref = 20;			//报错，const之后变为只读，不可修改
```



```
void showValue(int& ref)
{
	ref = 1000;
	cout<<ref<<endl;	//1000
}

int main()
{
	int a = 100;
	showValue(a);
	cout<<a<<endl;	//1000
}
```

防止像上方案例一样误操作导致函数改变原有数值：

```
void showValue(const int& ref)
{
	//ref = 1000;	//如果写这行会报错
	cout<<ref<<endl;	//100
}

int main()
{
	int a = 100;
	showValue(a);
	cout<<a<<endl;	//100
}
```



### 0.4 函数提高

#### 0.4.1 函数默认参数

函数的形参列表可以有默认值

- 如果某个位置有函数默认值 ，那么它以及它右侧的形参都必须有默认值（i.e. 从右到左都有）
- 如果自己传入数据，就用自己传入的
- 如果函数的声明有默认参数，函数实现就不能有默认参数（声明和实现只能有一个有默认参数）

```
int func(int a, int b = 20, int c = 30)
{
	return a+b+c;
}

int main()
{
	cout<< func(10,30) <<endl;	//70
}
```

```
int func2(int a = 10, int b = 10);

int func2(int a = 10, int b = 10)	//报错
{
	return a+b;
}
```



#### 0.4.2 函数的占位参数

用来占位，调用函数时需要填补该位置。

```
void func(int a, int)
{
	cout<<"This is a func"<<endl;
}

int main()
{
	func(10,5);
}
```

- 上面的例子中，**传入的占位的参数并没有实际作用，只是占位而已**
- 占位参数可以有默认参数



#### 0.4.3 函数重载

作用：函数名称可以相同，提高复用性

**满足条件：**

- 同一个作用域
- 函数名称相同
- 参数类型不同/个数不同/顺序不同

**函数返回值不作为函数重载条件！！！**

```
void func()
{
	cout<<"func"<<endl;
}

void func(int a)
{
	cout<<"myfunc"<<endl;
}

int main()
{
	func();	//输出：func
	func(2);	//输出：myfunc
}
```

都在全局作用域，名称相同，参数列表不同



**注意事项：**

1. **引用作为重载条件**

   ```
   void func(int& a)			//int& a = 10不合法
   {
   	cout<<"func1"<<endl;
   }
   
   void func(const int& a)		//const int& a = 10合法
   {
   	cout<<"func2"<<endl; 
   }
   
   //类型不同，可以重载 
   int main()
   {
   	int a = 10;
   	func(a);		//调用没有const的
   	func(10);		//调用const的
   }
   ```

   

2. **函数重载碰到默认参数**

   ```
   void func(int a)
   {
   	cout<<"func"<<endl;
   }
   
   void func(int a, int b = 10)
   {
   	cout<<"func2"<<endl;
   }
   
   int main()
   {
   	func(10);		//报错，因为两个函数都可以被调用
   	func(10，20);	//运行func2
   }
   ```







## 1. 类和对象

### 1.0 struct和class区别

唯一区别在于默认的访问权限不同

struct默认是公共，class默认是私有

```
class C1
{
	int m_A;	//默认私有
};

struct C2
{
	int m_A;	//默认公共
};

int main()
{
	C1 cl;
	c1.m_A = 100;	//报错，因为是私有，类外无法访问
	
	C2 c2;
	c2.m_A = 200;
}
```



### 1.1 封装

#### 1.1.1 成员函数私有化

通过自己设置接口，让类外可以访问类内私有成员

```
class Student
{
private:
	string m_name;
    
public:
	void set_name(string name)
	{
		m_name = name;
	}
	
	string get_name()
	{
		return m_name;
	}
};

int main()
{
	Student s1;
	s1.set_name("Hangyu");
	cout<<s1.get_name()<<endl;
}
```



#### 1.1.2 构造和析构函数

对象的初始化和清理

如果我们不提供构造和析构，编译器提供的构造和析构函数是空实现。



构造函数

- 可以有参数，因此可以发生重载
- 在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次

```
类名(){}
```

析构函数

- 不可以有参数，因此不可以重载
- 对象销毁前会自动调用析构，无需手动调用，而且只会调用一次

```
~类名(){}
```



构造函数的分类：

- 按参数：有参构造和无参（默认）构造
- 按类型：普通构造和拷贝构造

```
class Person
{
public:
	//无参
	Person()
	{
		cout<<"无参"<<endl;
	}
	
	//有参
	Person(int a)
	{
		cout<<"有参"<<endl;
		age = a;
	}
	
	//拷贝
	Person(const Person& p)	//加const从而使原有的Person类不被改变
	{
		cout<<"拷贝"<<endl;
		age = p.age;		//将传入的人身上所有属性拷贝到我的身上
	}
private:
	int age;
}
```



三种调用方式：

1. 括号法

   ```
   int main()
   {
   	Person p1;	//默认构造函数
   	Person p2(10);	//有参构造
   	Person p3(p2);	//拷贝构造
   }
   ```

   注意：调用默认构造函数时，不要加小括号，因为下面这行代码，编译器会认为是函数的声明

   ```
   Person p1();
   void func();
   ```

   

2. 显示法

   ```
   int main()
   {
   	Person p1;				//默认构造
   	Person p2 = Person(10);	//有参构造
   	Person p3 = Person(p2);	//拷贝构造
   	
   	Person(10);	//匿名对象。当执行结束后，系统会立即回收掉
   }
   ```

   注意：不要利用拷贝构造函数初始化匿名对象。编译器会认为Person (p3) === Person p3;导致重定义

   ```
   Person p3 = Person(10);	
   Person(p3); //拷贝构造，整体是一个匿名对象，报错
   ```

   

3. 隐式转换法

   ```
   Person p4 = 10;	//相当于 Person p4 = Person(10); 有参构造
   Person p5 = p4;	//拷贝构造
   ```



#### 1.1.3 拷贝构造函数调用时机

三种情况：

1. 使用一个已经创建完毕的对象来初始化一个新对象

2. 值传递的方式给函数参数传值

   ```
   class Person
   {
   public:
   	Person()
   	{
   		cout<<"moren"<<endl;
   	}
   	Person(const Person& p)
   	{
   		cout<<"kaobei"<<endl;
   	}
   	~Person()
   	{
   		cout<<"xigou"<<endl;
   	}
   };
   
   void doWork(Person p)	//实参传给形参会调用拷贝构造
   {
   
   }
   
   int main()
   {
   	Person p;
   	doWork(p);
   }
   ```

   输出：

   ```
   moren
   kaobei
   xigou
   xigou
   ```

   

3. 以值方式返回局部对象

   ```
   class Person
   {
   public:
   	Person()
   	{
   		cout<<"moren"<<endl;
   	}
   	Person(const Person& p)
   	{
   		cout<<"kaobei"<<endl;
   	}
   	~Person()
   	{
   		cout<<"xigou"<<endl;
   	}
   };
   
   Person doWork()
   {
   	Person p1;
   	cout<< (int*)&p1 <<endl;	//打印地址
   	return p1;		//返回的是p1的值，而不是p1
   }
   
   void test()
   {
   	Person p = doWork();	//doWork会返回一个新的对象，给p。所以拷贝构造
   	cout<< (int*)&p <<endl;	//打印地址
   }
   
   int main()
   {
   	test();
   }
   ```

   输出：

   ```
   moren
   kaobei
   xigou
   xigou
   ```

   

#### 1.1.4 构造函数调用规则

创建一个类，c++编译器会给每个类都添加至少3个函数：默认构造，析构函数，拷贝构造

- 如果用户定义有参构造函数，c++不再提供默认无参构造，但会提供默认拷贝构造。

  ```
  class Person
  {
  public:
      
      Person(int age)
      {
          m_age = age;
          cout<<"construct with elements"<<endl;
      }
      
      ~Person()
      {
          cout<<"destruct"<<endl;
      }
  
      int m_age;
  };
  
  int main()
  {
      Person p1;			//报错：没有合适的默认构造可用
      p1.m_age = 18;
      Person p2(p1);
      cout<<p2.m_age<<endl;
  }
  ```

  但会提供默认拷贝构造：

  ```
  int main()
  {
      Person p1(18);
      Person p2(p1);
      cout<<p2.m_age<<endl;
  }
  ```

  

- 编译器会提供默认拷贝构造

  ```
  class Person
  {
  public:
      Person()
      {
          cout<<"default construct with elements"<<endl;
      }
      Person(int age)
      {
          m_age = age;
          cout<<"construct with elements"<<endl;
      }
      
      /*注释掉，会执行默认拷贝构造
      Person(const Person& p)
      {
          m_age = p.m_age;
          cout<<"copy construct with elements"<<endl;
      }
      */
      
      ~Person()
      {
          cout<<"destruct"<<endl;
      }
  
      int m_age;
  };
  
  int main()
  {
      Person p1;
      p1.m_age = 18;
      Person p2(p1);
      cout<<p2.m_age<<endl;
  }
  ```

  输出：

  ```
  default construct with elements
  //copy construct with elements 注释掉用户自定义的拷贝构造之后，就不会打印这句话
  18
  destruct
  destruct
  ```

  

- 如果用户定义拷贝构造函数，c++不会提供其他构造函数

  ```
  class Person
  {
  public:
      Person(const Person& p)
      {
          m_age = p.m_age;
          cout<<"copy construct with elements"<<endl;
      }
      
      ~Person()
      {
          cout<<"destruct"<<endl;
      }
  
      int m_age;
  };
  
  int main()
  {
      Person p1;			//报错
      p1.m_age = 18;
      Person p2(p1);
      cout<<p2.m_age<<endl;
  }
  ```

   

### 1.2 深拷贝和浅拷贝

浅拷贝：简单的赋值拷贝操作

深拷贝：堆区重新申请空间，再进行拷贝操作



堆区：程序员手动开辟和释放

```
class Person
{
public:
	Person()
	{
		cout<<"默认构造"<<endl;
	}
	Person(int age, int height)
	{
		cout<<”有参构造""<<endl;
		m_age = age;
		m_height = new int(height);
	}
	~Person()
	{
		//将堆区开辟的数据进行释放
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
		
		cout<<"析构函数调用"<<endl;
	}
	
	int m_age;
	int *m_height;
}

void test()
{
    Person p1(18,160);
    cout<<"p1 age is "<<p1.age<<"height is "<<*p1.m_height<<endl;	//18
    
    Person p2(p1);
    cout<<"p2 age is "<<p1.age<<endl;	//18拷贝构造
}
```

**对于析构函数，p2的析构会先被调用。因为栈是先进后出。**

但这样写会出现问题。



对于`Person p2(p1)`来讲，**利用编译器提供的拷贝构造函数，会做浅拷贝操作**：

![image-20230614105841272](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230614105841272.png)

此时，因为p2先执行析构函数，导致堆区内存被释放，所以p1再执行析构函数时，会报错。（内存重复释放）



#### 1.2.1 浅拷贝带来的问题

堆区内存重复释放

所以要利用深拷贝：

![image-20230614110109611](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230614110109611.png)

此时，虽然m_height的数据相同，但是他们指向的是两个地址的数据。不会造成内存重复释放。



#### 1.2.2 深拷贝构造函数

实现深拷贝：重写（自定义）拷贝构造函数 

```
#include <iostream>

using namespace std;

class Person
{
public:
	Person()
	{
		cout<<"moren"<<endl;
	}
	Person(int age, int height)
	{
		cout<<"youcan"<<endl;
		m_age = age;
		m_height = new int(height);
	}

    //自己实现拷贝构造
	Person(const Person&p)
	{
		cout<<"kaobei"<<endl;
		//浅拷贝
		m_age = p.m_age;
		
		//m_height = p.m_height;		//编译器默认实现的是这行代码
		
		//深拷贝
		m_height = new int(*p.m_height);	//解引用后是int，相当于再分配int大小的内存
	}

	~Person()
	{
		//将堆区开辟的数据进行释放
		if(m_height != NULL)
		{
			delete m_height;
			m_height = NULL;
		}
		
		cout<<"xigou"<<endl;
	}
	
	int m_age;
	int *m_height;
};

void test()
{
    Person p1(18,160);
    cout<<"p1 age is "<<p1.m_age<<" height is "<<*p1.m_height<<endl;	//18 160
    
    Person p2(p1);
    cout<<"p2 age is "<<p1.m_age<<" height is "<<*p2.m_height<<endl;//18 160自定义的拷贝构造
}

int main(int argc, char const *argv[])
{
    test();
    return 0;
}
```

输出

```
youcan
p1 age is 18 height is 160
kaobei
p2 age is 18 height is 160
xigou
xigou
```



**如果属性有在堆区开辟的，一定要自己写拷贝构造函数，防止浅拷贝带来的问题**



### 1.3 初始化列表

```
class Person
{
public:
	Person(int a, b, c):m_A(a),m_B(b),m_C(c){}
	
	int m_A;
	int m_B;
	int m_C
};
```



### 1.4 类对象作为类成员(对象成员)

```
class A{};

class B
{
	A a;
};
```

A为对象成员



问题：创建B对象时，A和B的构造和析构顺序？

```
#include <iostream>

using namespace std;

class Phone
{
public:
    Phone(string pname):m_pname(pname)
    {
        cout<<"Phone gouzao"<<endl;
    }
    ~Phone()
    {
        cout<<"Phone xigou"<<endl;
    }

    string m_pname;
};

class Person
{
public:
    //Phone m_Phone = pName 隐式转换
    Person(string name, string pName):m_name(name), m_phone(pName)
    {
        cout<<"person gouzao"<<endl;
    }
    ~Person()
    {
        cout<<"Person xigou"<<endl;
    }
    
    string m_name;
    Phone m_phone;
};

void test()
{
    Person p1("zhangsan","iphone");
    cout<<p1.m_name<< " " <<p1.m_phone.m_pname <<endl;
}

int main(int argc, char const *argv[])
{
    
    test();
    return 0;
}

```

输出：

```
Phone gouzao
person gouzao
zhangsan iphone
Person xigou
Phone xigou
```



总结：

**当其他类对象作为本类成员，构造时候先构造类对象，再构造自身**

**析构顺序与构造顺序相反**



### 1.5 静态成员

静态成员是成员变量和成员函数前加static



#### 1.5.1 静态成员变量

- 所有对象共享同一份数据：只有一份

- 在编译阶段分配内存（全局区）

- 类内声明，类外初始化（必须做类外初始化，否则直接访问会报错）


```
class Person
{
public:
	
	//所有对象共享同一份
	static int m_A;
};

//类外初始化
int Person::m_A = 100;

int main()
{
	Person p;
	cout<<p.m_A<<endl;		//100
	
	Person p2;
	p2.m_A = 200;
	
	cout<<p.m_A<<endl;		//200
}
```

静态成员变量不属于某个对象，所有对象共享同一份数据



##### 静态成员变量两种访问方式：

- 通过对象访问

- 通过类名访问


```
class Person
{
public:
	
	//所有对象共享同一份
	static int m_A;
};
//类外初始化
int Person::m_A = 100;

int main()
{
	//通过类名访问
	cout<<Person::m_A<<endl;
	
	//通过对象访问
	Person p;
	cout<<p.m_A<<endl;
}
```



##### 静态成员变量访问权限

静态成员变量也是有访问权限的，如果是私有静态成员变量，同样不能直接类外访问

```
class Person
{
private:
	
	//所有对象共享同一份
	static int m_A;
};

int Person::m_A = 10;

int main()
{
	//通过类名访问
	cout<<Person::m_A<<endl;	//报错inaccesible
}
```



#### 1.5.2 静态成员函数

- 所有对象共享同一个函数

- **只能**访问静态成员变量
- 也可以通过对象或者通过类名访问



1）所有对象共享同一个函数：

```
class Person
{
public:
	static void func()
	{
		cout<<"static void func"<<endl; 
	}
};

int main()
{
	//通过对象访问
	Person p;
	p.func();
	
	//通过类名访问
	Person::func();
}
```



2）只能访问静态成员变量：

3）静态成员函数也有访问权限（类外访问不到private的成员函数）：

```
class Person
{
public:
	static void func()
	{
		m_A = 100;
		//m_B = 200;		//报错，静态成员函数只能访问静态成员变量
		cout<<"static void func"<<endl;
	}
	
	static int m_A;
	int m_B;	//非静态成员变量
	
	//静态成员函数也有访问权限
private:
	static void func2()
	{
		cout<<"func2"<<endl;
	}
};

int Person::m_A = 0;

int main()
{
	//通过对象访问
	Person p;
	p.func();
	
	//通过类名访问
	Person::func();
	
	Person::func2();	//报错，静态成员函数不能类外调用
}
```



### 1.6 成员变量和成员函数分开储存

- c++中，类内成员变量和成员函数分开储存

- 只有非静态的成员变量才属于类的对象上

```
class Person
{
	int m_A;				//非静态成员变量，属于类的对象上
	static int m_B;			//静态成员变量，不属于类的对象上
	void func(){}			//非静态成员函数，不属于类的对象上
	static void func2(){}	//静态成员函数，不属于类的对象上
}
```



#### 1.6.1 空对象占用的空间：1字节

```
class Person
{

};

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```

原因：

C++编译器会给每个空对象也分配一个字节空间，为了区分空对象占内存的位置

每个空对象应该有一个独一无二的内存地址



#### 1.6.2 有非静态成员变量的类占用的空间：根据变量大小

```
class Person
{
	int m_a;	//属于类的对象上
};

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//4
}

int main()
{
	test();
}
```



 #### 1.6.3 有静态成员变量的类占用的空间

静态成员变量**不占用空间**，不属于类的对象上

```
class Person
{
	static int m_a;	//静态成员变量，不属于类的对象上
};

int Person::m_a = 0;

void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```



#### 1.6.4 非静态成员函数的类占用的空间

成员函数**不占用空间**，不属于类的对象上

```
class Person
{
	void func(){}
};


void test()
{
	Person p;
	cout<<"sizeof p is "<< sizeof(p)<<endl;	//1
}

int main()
{
	test();
}
```



静态成员函数同样也不属于类的对象上



### 1.7 this指针

每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码。

为了区分是哪一个对象调用自己：this指针

this指针指向被调用的成员函数 所属的对象

目的：

- 解决命名冲突：当形参和成员变量同名时
- 返回类本身: return *this：在类的非静态（non-static）成员函数中返回对象本身



this指针本质：指针常量，指向不可以修改。但指向的值可以修改



```
/*实现PersonAddAge功能，可以把一个对象的年龄多次加到另一个对象的年龄上*/

class Person
{
public:
	Person(int age)
	{
		this->age = age;
	}
	
	Person& PersonAddAge(Person &p)	//要返回本体，所以用引用类型
	{
		this->age += p.age;
		return *this;		//返回一个类
	}
	
	int age;
};

void test()
{
	Person p1(10);
	Person p2(10);
	
	p2.PersonAddAge(p1).PersonAddAge(p1);	//链式编程
	cout<<"age of p2: "<<p2.age<<endl;
}

int main(int argc, char const *argv[])
{
    test();
    return 0;
}
```

输出：

```
age of p2: 30
```

**注意点：**

返回值写成`Person &`类型，这样可以一直在当前类相加。否则最终结果为20。因为相当于第一次`p2.PersonAddAge(p1)`运行了，p2的age变成了20。但是，由于返回的是一个新的类型，相当于`新类型.PersonAddAge(p1)`，所以p2的值不会改变。



### 1.8 空的类指针访问成员函数

要注意有无this指针

```
class Person
{
public:
	void showClassName()
	{
		cout<<"This is Person class"<<endl;
	}
	
	void showPersonAge()
	{
		cout<<"age = "<<m_Age<<endl;
	}
	
	int m_Age;
};

void test()
{
	Person *p = NULL;
	
	p->showClassName();
	p->showPersonAge();	//报错
}

int main()
{
	test();
}
```

对于类中的对象，其实都存在一个this的指针：m_Age其实是this->m_Age

由于this本身就是NULL，所以肯定会报错：`NULL->m_Age`



改进：

```
class Person
{
public:
	void showClassName()
	{
		cout<<"This is Person class"<<endl;
	}
	
	void showPersonAge()
	{
		if(NULL == this)
		{
			return;
		}
		cout<<"age = "<<m_Age<<endl;
	}
	
	int m_Age;
};

void test()
{
	Person *p = NULL;
	
	p->showClassName();
	p->showPersonAge();	//
}

int main()
{
	test();
}
```



### 1.9 const修饰

#### 1.9.1 修饰成员函数（常函数）

常函数：

- 成员函数后加const，我们称这个函数为常函数
- **常函数内不能修改成员属性**
- 成员属性声明时加mutable关键字后，在常函数/常对象中仍然可以修改



我们知道，this是一个指针常量，指向是不可以改变的：在类内`this = NULL`是错误的

加了const其实修饰的是this指针，让指针指向的值也不可以被修改。

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230901173451005.png" alt="image-20230901173451005" style="zoom:70%;" />

```
class Person
{
public:
	void showPerson() const
	{
		m_A = 100;		//报错
		this->m_A = 100;		//和上面一样，报错
		
		m_B = 200;		//可以修改
	}
	
	int m_A;
	mutable int m_B;	//加关键字，即使在常函数中也能修改
};
```



#### 1.9.2 修饰对象（常对象）

常对象：

- 声明对象前加const
- 常对象只能调用常函数/const成员变量
- mutable修饰的成员变量可以在常对象中修改



一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数）

```
class Person
{
public:
	void showPerson() const
	{
		m_B = 200;		//可以修改
	}
	
	void func()
	{
		m_A= 200;
	}
	
	int m_A;
	mutable int m_B;	//加关键字
};

void test()
{
	const Person p;
	p.m_A = 100;	//报错
	p.m_B = 300;	//可以修改
	
	p.showPerson();	//可以，因为是常函数
	p.func();		//报错
}
```



注意：有些编译器g++中，不能直接声明`const Person p` ，需要自己写构造函数

```
#include <iostream>

using namespace std;

class Person
{
public:
    Person(int a, int b):m_A(a),m_B(b){}

    int m_A;
	mutable int m_B;	//加关键字

	void showPerson() const
	{
		m_B = 200;		//可以修改
	}
	
	void func()
	{
		m_A= 200;
	}
};

void test()
{
	const Person p(10,20);
	//p.m_A = 100;	//报错
	p.m_B = 300;	//可以修改
	
	p.showPerson();
    cout<<p.m_B<<endl;
	//p.func();		//报错
}

int main()
{
    test();
}
```

[关于C ++：未初始化的const | 码农家园 (codenong.com)](https://www.codenong.com/8092670/)

[c++ - 我真的需要为const对象实现用户提供的构造函数吗？ - IT工具网 (coder.work)](https://www.coder.work/article/7138240)



### 1.10 友元

可以让类外的一些函数或者其他类访问当前类中的私有属性的成员

关键字：friend



三种实现：

- 全局函数做友元
- 类做友元
- 成员函数做友元



#### 1.10.1 全局函数做友元

全局函数在类中加上friend关键字

```
class Building
{
	friend void visit(Building* building);
	
public:
	Building()
	{
		m_SittingRoom = "sr";
		m_BedRoom = "br";
	}
	
	string m_SittingRoom;
	
private:
	string m_BedRoom;
};

void visit(Building* building)
{
	cout<<"Visit sitting room "<< building->m_SittingRoom <<endl;
	cout<<"Visit bedroom "<< building->m_BedRoom <<endl;
}

int main()
{
	Building b;
	visit(&b);
}
```



#### 1.10.2 类做友元

在类中声明友元类。



##### 类外实现成员/构造函数

```
class Building;

class myFriend
{
public:
	myFriend();
	Building * building;
	void visit();	//参观函数，访问Building中的属性
};


class Building
{	
	friend class myFriend;
public:
	Building();
	string m_SittingRoom;
	
private:
	string m_BedRoom;
};


//类外实现成员构造
Building::Building()
{
	m_SittingRoom = "sr";
	m_BedRoom = "br";
}

myFriend::myFriend()
{
	//创建building类对象
	building = new Building;
}

void myFriend::visit()
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	cout<<"visiting "<<building->m_BedRoom<<endl;
}

void test()
{
	myFriend f;
	f.visit();
}

int main()
{
    test();
}
```



#### 1.10.3 成员函数做友元

类中申明另一个类中的函数加friend关键字

```
class Building;

class myFriend
{
public:
	myFriend();

	Building *building;
	
	void visit();
	void visit2();
};

class Building
{
	friend void myFriend::visit();	//告诉Building, myFriend下的visit成员函数为友元，可以访问私有内容。

public:
	Building();
	string m_SittingRoom;
private:
	string m_BedRoom;
};


Building::Building()
{
	m_SittingRoom = "sr";
	m_BedRoom = "br";
}

myFriend::myFriend()
{
	building = new Building;
}

void myFriend::visit()	//可以访问Building中私有成员
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	cout<<"visiting "<<building->m_BedRoom<<endl;
}

void myFriend::visit2()	//不可以访问Building中私有成员
{
	cout<<"visiting "<<building->m_SittingRoom<<endl;
	//cout<<"visiting "<<building->m_BedRoom<<endl;
}

void test()
{
	myFriend f;
	f.visit();
	f.visit2();
}

int main()
{
	test();
}
```



### 1.11运算符重载

对已有的运算符进行重定义



#### 1.11.1 加号运算符重载

实现两个自定义数据类型相加的运算



两种方法：

- 成员函数进行重载
- 全局函数进行重载



![image-20230615104341036](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230615104341036.png)



##### 1）成员函数重载运算符

```
class Person
{
public:
	int m_A;
	int m_B;
	Person operator+ (Person &p)
	{
		Person temp;
		temp.m_A = this->m_A + p.m_A;
		temp.m_B = this->m_B + p.m_B;
		return temp;
	}
};

void test1()
{
	Person p1;
	p1.m_A = 10;
	p1.m_B = 10;
	
	Person p2;
	p2.m_A = 10;
	p2.m_B = 10;
	
	Person p3 = p1+p2;	//本质：p3 = p1.operator+(p2)
	cout<<p3.m_A<<endl;
    cout<<p3.m_B<<endl;
}

int main()
{
    test1();
}
```



##### 2）全局函数重载运算符

```
class Person
{
public:
	int m_A;
	int m_B;
};

Person operator+ (Person &p1, Person &p2)
{
	Person temp;
	temp.m_A = p1.m_A + p2.m_A;
	temp.m_B = p1.m_B + p2.m_B;
	return temp;
}

void test1()
{
	Person p1;
	p1.m_A = 10;
	p1.m_B = 10;
	
	Person p2;
	p2.m_A = 10;
	p2.m_B = 10;
	
	Person p3 = p1+p2;	//本质：p3.operator+(p1,p2)
	cout<<"p3 m_A is "<<p3.m_A<<endl;
    cout<<"p3 m_B is "<<p3.m_B<<endl;
}

int main()
{
    test1();
}
```



##### 3）利用函数重载实现类和整型相加

基于上面的代码

```
Person operator+ (Person &p, int num)
{
	Person temp;
	temp.m_A = p.m_A + num;
	temp.m_B = p.m_B + num;
	return temp
}

void test2()
{
	Person p4;
	p4 = p1+20;
}
```

 

#### 1.11.2 左移运算符重载<<

可以输出自定义的类型



##### 1）利用成员函数重载(通常不用)

```
class Person
{
public:
	int m_A;
	int m_B;
	
	void operator<< (Person& p)
	{}
};
```

这样会出现一个问题，我们最后调用的时候会写成`p.operator<<(p)`，这样不符合我们想要的逻辑。而且无法实现cout在左侧



##### 2）利用全局函数

```
class Person
{
public:
	int m_A;
	int m_B;
};

void operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
}

void test()
{
	Person p;
	p.m_A = 10;
	p.m_B = 10;
	cout << p;
}

int main()
{
	test();
}
```



**Q1: 为啥重载函数的`ostream & cout`的参数必须是引用？**

因为不引用的话，相当于传值，也就是要拷贝一份cout对象，但是ostream里面的拷贝构造函数是protected的，无法拷贝。



**Q2: 连续地输出cout<<m<<endl;？**

上面的代码有一个问题，就是`cout<<p`后不能加endl。我们需要考虑链式编程，从而实现追加输出。

改正：返回一个输出流ostream引用类型

```
class Person
{
public:
	int m_A;
	int m_B;
};

ostream& operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
	return cout;
}

void test()
{
	Person p;
	p.m_A = 10;
	p.m_B = 10;
	cout << p << endl;
}

int main()
{
	test();
}
```



##### 3）如果是私有属性，利用友元函数:

```
class Person
{
	friend ostream& operator<< (ostream & cout, Person p);
priavte:
	int m_A;
	int m_B;
public:
	Person(int a, int b):m_A(a),m_B(b){}
};

ostream& operator<< (ostream & cout, Person p)
{
	cout<< "m_A = "<< p.m_A << "m_B = "<< p.m_B;
	return cout;
}

void test()
{
	Person p(10,10);
	cout << p << endl;
}

int main()
{
	test();
}
```





#### 1.11.3 递增运算符重载

![image-20230615150805263](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230615150805263.png)

步骤：

step1: 自定义整型

step2: 重载左移运算符

step3：重载（前置）递增运算符，注意返回值是本类的引用

```
class MyInteger
{
	friend ostream& operator<<(ostream& cout, MyInteger myint);
public:
	MyInteger()
	{
		m_Num = 0;
	}
	
	MyInteger& operator++()
	{
		m_Num++;
		return *this;
	}
	
private:
	int m_Num;
};

ostream& operator<<(ostream& cout, MyInteger myint)
{
	cout<< myint.m_Num;
	return cout;
}



void test()
{
	MyInteger myint;
	
	cout << myint << endl;
}

int main()
{
	test();
}
```



#### 1.11.4 赋值运算符重载

编译器自带的赋值运算是浅拷贝，如果我们把变量创建在堆区，释放时会出现重复释放的问题。

解决方法是对赋值运算符重载。



```
class Person
{
public:
	Person(int age){
		m_Age = new int (age);
	}
	
	int* m_Age;
	
	~Person()
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}
};

int main()
{
	Person p1(18);
	Person p2(20);
	
	p2 = p1;
}
```



出现的问题：浅拷贝导致释放两次

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230630105101685.png" alt="image-20230630105101685" style="zoom:80%;" />

解决方法：重载赋值运算符

```
class Person
{
public:
	Person(int age){
		m_Age = new int (age);
	}
	
	int* m_Age;
	
	~Person()
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}
	Person& operator =(Person &p)
	{
		if(m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		
		m_Age = new int(*p.m_Age);
		return *this;
	}
};

int main()
{
	Person p1(18);
	Person p2(20);
	Person p3(30);
	
	p3 = p2 = p1;
	
	cout<<*p1.m_Age<<endl;
	cout<<*p2.m_Age<<endl;
	cout<<*p3.m_Age<<endl;
}
```



#### 1.11.5 关系运算符==, !=

两个自定义数据类型比较关系



```
class Person
{
public:
	string m_Name;
	int m_Age;
	
	Person(string name, int age)
	{
		m_Name = name;
		m_Age = age;
	}
	
	//重载关系运算符
	bool operator == (Person &p)
	{
		if(this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return true;
		}
		return false;
	}
	
	bool operator != (Person &p)
	{
		if(this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return false;
		}
		return true;
	}
	
};

void test01()
{
	Person p1("Tom", 18);
	Person p2("Tom", 18);
	
	if(p1 == p2)
	{
		cout<<"p1 equals to p2"<<endl;
	}
	else if(p1 != p2)
	{
		cout<<"p1 not equals to p2"<<endl;
	}
}
```



#### 1.11.6 函数调用运算符()

由于重载后使用的方式像函数的调用，因此称为仿函数

没有固定写法，非常灵活



```
class MyPrint
{
public:
	void operator () (string test)
	{
		cout << test <<endl;
	}

};

int main()
{
	MyPrint myPrint;
	myPrint("hello world");
	
	//匿名对象
	MyPrint()("hello world"); 
}
```



### 1.12 类的继承

好处：减少重复代码

语法：`class 子类：继承方式 父类`



子类==派生类，父类==基类

子类包含继承来的共性和特性



#### 1.12.1 继承方式 

公共继承，保护继承，私有继承



派生类无法访问基类的private成员



public继承：  子类继承后的访问权限不变 

protected继承：  子类继承后，父类中的public变成protected，其它不变(protected:只有子类内可以用)，类外不可用

private继承：   子类继承后，父类中的public和protected变成private，其他不变



```
class A
{
protected:
	int a;
	
public:
	A(int a):a(a){}
	void show()
	{
		cout<<a<<endl;
	}
};

class B: protected A
{
public:
	B(int a):A(a){}
};

int main()
{
	B b(10);
	b.show();	//错误，show函数是protected的，只能类内使用
}
```

改正：

```
class A
{
protected:
	int a;
	
public:
	A(int a):a(a){}
	void show()
	{
		cout<<a<<endl;
	}
};

class B: protected A
{
public:
	B(int a):A(a){}
	void dis()
	{
		show();		//在子类中使用，没有问题
	}
};

int main()
{
	B b(10);
	b.dis();
}
```



#### 1.12.2 继承中对象模型大小

父类中**所有非静态成员属性**都会被子类继承下去

父类中私有成员属性是被编译器隐藏，所以访问不到，但是确实被继承了

```
class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

class Son: public Base
{
public:
	int m_D;
};

void test01()
{
	cout<<sizeof(son)<<endl;	//16 bytes
}
```

相当于继承了父类的三个属性，并且加上了自身的属性



补充：利用开发人员命令提示工具查看对象模型

```
1. 跳转盘符
2. 跳转文件路径cd具体目录
3. 查看命名
cl /d1 reportSingleClassLayout类名 文件名

```



#### 1.12.3 继承中构造和析构顺序

子类构造时，也会调用父类的构造函数。

```
class Base
{
public:
	Base()
	{
		cout<<"Base constructor"<<endl;
	}
	
	~Base()
	{
		cout<<"Base destructor"<<endl;
	}
};

class Son: public Base
{
public:
	Son()
	{
		cout<<"Son constructor"<<endl;
	}
	~Son()
	{
		cout<<"Son destructor"<<endl;
	}
};

int main()
{
	Son s;
}
```

输出：

```
Base constructor
Son constructor
Son destructor
Base destructor
```

结论：

先构造父类，在构造子类；析构顺序与构造顺序相反



#### 1.12.4 继承中同名成员的处理方式

##### 同名成员变量：

 ```
 class Base
 {
 public:
 	Base()
 	{
 		m_A = 100;
 	}
 	
 	int m_A;
 };
 
 class Son: public Base
 {
 public:
 	Son()
 	{
 		m_A = 200;
 	}
 	
 	int m_A;
 };
 
 int main()
 { 
 	Son s;
 	cout<<s.m_A<<endl;		//200
 	
 	cout<<s.Base::m_A<<endl;	//100
 }
 ```

默认调用的是子类的成员，如果想访问父类成员，需要加一个作用域符号`::`



##### 同名成员函数：

```
class Base
{
public:
	void func()
	{
		cout<<"Base func"<<endl;
	}
	
	void func(int num)
	{
		cout<<"Base func num"<<endl;
	}
};

class Son: public Base
{
public:
	void func()
	{
		cout<<"Son func"<<endl;
	}
};

int main()
{
	Son s;
	s.func();
	s.Base::func();
	s.func(100);		//报错，子类会隐藏掉父类同名的成员函数
}
```

如果子类中出现和父类同名的成员函数，子类的同名成员函数会隐藏掉父类中所有同名的成员函数



对比：

```
class Base
{
public:
	void func()
	{
		cout<<"Base func"<<endl;
	}
	
	void func(int num)
	{
		cout<<"Base func num"<<endl;
	}
};

class Son: public Base
{
public:

};

int main()
{
	Son s;
	s.func(100);		//不报错
}
```



1. 子类对象可以直接访问到子类中的同名成员
2. 子类对象加作用域可以访问到父类同名成员
3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名的成员函数，但是可以加作用域`::`访问到父类中同名函数



#### 1.12.5 继承同名静态成员的处理方式

* 回顾静态成员变量（Section 1.5）：

所有对象共享同一个变量

编译时分配内存（全局）

**类内声明，类外实现** `int Person::m_A = 10;`

两种访问方式：通过类名访问，通过对象访问 `Person::m_A` or `p.m_A`



* 回顾静态成员函数：

所有对象共享同一个函数

只能访问静态变量

两种访问方式：通过类名访问，通过对象访问 `Person::func()`



和非静态成员出现同名的处理方式一致：

- 可以直接访问子类同名成员 `s.m_A` or `Son::m_A`

- 访问父类同名成员，需要加作用域 `Son::Base::m_A`




##### 同名静态成员变量

```
class Base
{
public:
	static int m_A;
	
};

int Base::m_A = 100;		//静态成员变量要在类外实现

class Son: public Base
{
public:
	static int m_A;
}

int Son::m_A = 200;


//通过对象访问数据
void test()
{
	Son s;
	cout<<s.m_A<<endl;		//200
	
	cout<<s.Base::m_A <<endl;	//100
}

//通过类名访问数据
void test1()
{
	cout<<Son::m_A<<endl;
	cout<<Base::m_A<<endl;
	cout<<Son::Base::m_A<<endl;	//和上面一样，第一个双冒号表示通过类名访问，第二个表示父类作用域下
}

int main()
{
	test();
	test1();
}
```



##### 同名静态成员函数

```
class Base
{
public:
	static void func()
	{
		cout<<"Base func"<<endl;
	}
};

class Son: public Base
{
public:
	static void func()
	{
		cout<<"Son func"<<endl;
	}
}

//通过对象访问数据
void test()
{
	Son s;
	cout<<s.func()<<endl;		
	cout<<s.Base::func() <<endl;	
}

//通过类名访问
void test1()
{
	cout<<Son::func()<<endl;		
	cout<<Base::func() <<endl;	
	cout<<Son::Base::func()<<endl;
}
```



#### 1.12.6 多继承

一个类继承多个类

`class 子类：继承方式 父类，继承方式 父类`



多继承会引发父类中有同名成员出现（二义性），需要加作用域区分

实际开发中不建议使用



假设两个父类都有同名成员m_A：

 ```
 class Base1
 {
 public:
 	Base1()
 	{
 		m_A = 100;
 	}
 	
 	int m_A;
 };
 
 class Base2
 {
 public:
 	Base2()
 	{
 		m_A = 200;
 	}
 	
 	int m_A;
 };
 
 class Son: public Base1, public Base2
 {
 public:
 	Son()
 	{
 		m_C = 300;
 		m_D = 400;
 	}
 	
 	int m_C;
 	int m_D;
 };
 
 void test()
 {
 	Son s;
 	cout<<sizeof(s)<<endl;		//16
 	cout<<s.Base1::m_A<<endl;	//100
 	cout<<s.Base2::m_A<<endl;	//200
 }
 
 int main()
 {
 	test();
 }
 ```



#### 1.12.7 菱形继承

两个派生类继承一个基类，又有一个类同时继承这两个派生类

出现的问题：

* 二义性

* 继承了两份数据，但其实只要一份



```
class Animal()
{
public:
	int m_Age;
};

class Sheep :public Animal
{};

class Tuo : public Animal
{};

class SheepTuo: public Sheep, public Tuo
{};

void test()
{
	SheepTuo st;
	//st.m_Age = 18;		//报错，不明确，因为Sheep和Tuo都有m_Age
	st.Sheep::m_Age= 18；
	st.Tuo::m_Age = 28;
	cout<<st.Sheep::m_Age<<endl;
	cout<<st.Tuo::m_Age<<endl;
}
```



解决方法：虚继承

#### 1.12.8 虚继承

解决菱形继承的问题，所有类都共享同一份成员变量

```
class Animal()
{
public:
	int m_Age;
};

class Sheep :virtual public Animal
{};

class Tuo : virtual public Animal
{};

class SheepTuo: public Sheep, public Tuo
{};

void test()
{
	SheepTuo st;
	st.Sheep::m_Age= 18；
	st.Tuo::m_Age = 28;
	cout<<st.Sheep::m_Age<<endl;	//28
	cout<<st.Tuo::m_Age<<endl;		//28
	cout<<st.m_Age<<endl;			//28，可以多一种访问方式
}

int main()
{
	test();
}
```



##### 虚基类指针：vbptr，指向vbtable（虚基类表 ）：

虚基类表记录的是偏移量，通过偏移量，虚基类指针可以找到m_Age

<img src="C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230908005158232.png" alt="image-20230908005158232" style="zoom:80%;" />



### 1.13 多态

两类：

静态多态：函数重载/运算符重载都属于静态多态，复用函数名

动态多态：派生类和虚函数实现运行时多态



**两者区别：**

- 静态多态的函数地址早绑定，编译阶段确定函数地址

- 动态多态的函数地址晚绑定，运行阶段确定函数地址




```
class Animal
{
public:
	void speak()
	{
		cout<<"animal is speaking"<<endl;
	}
};

class Cat : public Animal
{
public:
	void speak()
	{
		cout<<"cat is speaking"<<endl;
	}
};

//地址早绑定：编译阶段确定函数地址
void doSpeak(Animal &animal)
{
	animal.speak();
}

void test()
{
	Cat cat;
	doSpeak(cat);	//Animal& animal = cat
}

int main()
{
	test();		//animal is speaking
}
```

c++中，父子类型可以自动转换：`Animal& animal = cat`

但由于静态多态，函数地址早绑定，所以不会输出cat is speaking



改正： 

#### 1.13.1 虚函数

动态多态满足条件：

- 有继承关系
- 子类**重写**父类的虚函数

```
class Animal
{
public:
	virtual void speak()	//   虚函数
	{
		cout<<"animal is speaking"<<endl;
	}
};

class Cat : public Animal
{
public:
	void speak()
	{
		cout<<"cat is speaking"<<endl;
	}
};

class Dog : public Animal
{
public:
	void speak()
	{
		cout<<"dog is speaking"<<endl;
	}
};

void doSpeak(Animal &animal)
{
	animal.speak();
}

void test()
{
	Cat cat;
	doSpeak(cat);	
	
	Dog dog;
	doSpeak(dog);
}

int main()
{
	test();
}
```

输出

```
cat is speaking
dog is speaking
```



#### 1.13.2 函数重写Override

假设基类和派生类都具有一个具有**相同名称和参数列表**（参数的数量和类型）的成员函数。

如果创建派生类的对象并调用在两个类（基类和派生类）中都存在的成员函数，则将调用派生类的成员函数，而忽略基类的函数。



回顾1.12.4中，同名成员函数：

```
class Base
{
public:
	void getData()
	{
		...
	}
};

class Derived : public Base
{
public:
	void getData()
	{
		...
	}
};

int main()
{
	Derived obj;
	obj.getData();		//只会调用子类的getData()
}
```

如果想从派生类访问基类的重写函数，则需要加定义域运算符::



**注意：**如果基类的函数是虚函数，那么派生类中重写的函数也是虚函数，不用写virtual关键字也可



#### 1.13.3 多态构成条件：

- 必须存在继承关系

- 继承关系中必须有同名的虚函数，并且形参覆盖（重写）关系。

- 存在基类的指针/引用，通过该指针调用虚函数：父类指针/引用指向子类对象




#### 1.13.4 虚函数表/虚函数表指针

```
class Animal
{
public:
	virtual void speak()
	{
		cout<<"animal is speaking"<<endl;
	}
};

class Cat : public Animal
{
public:
	void speak()
	{
		cout<<"cat is speaking"<<endl;
	}
};

void doSpeak(Animal &animal)
{
	animal.speak();
}

void test()
{
	cout<<"sizeof animal"<<sizeof(Animal)<<endl;		// 4 bytes
}

int main()
{
	test();
}
```

为什么占4个字节？（如果不写virtual，相当于空类，只占一个字节）

原因：包含了一个指针----虚函数（表）指针 vfptr：virtual function pointer

指向了一个vftable：virtual function table虚函数表



![image-20230708193044453](C:\Users\henry0408\AppData\Roaming\Typora\typora-user-images\image-20230708193044453.png)

当父类的指针或引用指向子类对象，发生多态时：

```
Animal &animal = cat;
animal.speak();
```

会找子类的接口（也就是cat的speak函数）



#### 1.13.5 多态优点

代码组织结构清晰，可读性强

利于前期和后期的扩展以及维护



例子：多态实现计算器

```
#include <iostream>

using namespace std;

class virtualCalculator
{
public:
    int num1;
    int num2;

    virtual int operation ()
    {
        return 0;
    }
};

class SumCalculator : public virtualCalculator
{
public:
    int operation ()
    {
        return num1+num2;
    }
};

class SubCalculator : public virtualCalculator
{
public:
    int operation ()
    {
        return num1-num2;
    }
};

int main()
{
    virtualCalculator *vc = new SumCalculator;	//父类指针指向子类对象
    vc->num1 = 10;
    vc->num2 = 10;

    cout<< vc->num1 <<" + "<<vc->num2<< " = " << vc->operation() <<endl;
    delete vc;	//记得销毁

    vc = new SubCalculator;
    vc->num1 = 10;
    vc->num2 = 10;

    cout<< vc->num1 <<" - "<<vc->num2<< " = " << vc->operation() <<endl;
    delete vc;
}
```



#### 1.13.6 纯虚函数和抽象类

发现父类的虚函数没太大意义，所以可以改成纯虚函数



纯虚函数语法：

```
virtual 返回类型 函数名 (参数列表) = 0;
```



**抽象类：当类中有纯虚函数时，这个类就是抽象类**

特点：

* 无法实例化对象（无论栈/堆）
* 子类中必须重写抽象类（父类）的纯虚函数，否则这个子类也属于抽象类



```
class Base
{
public:
	virtual void func() = 0;
};

class Son : public Base
{
public:
	void func()
	{
		cout<<"func"<<endl;
	}
};

void test1()
{
	//Base base;	//报错，不允许
	//Base* base = new Base;	//报错，不允许 
	
	Base *base = new Son;
	base->func();
}

int main()
{
	test1();
}
```



例子：制作饮品

步骤（基类）：煮水boil，冲泡brew，倒入杯中pour，加入辅料

多态实现制作咖啡和茶（子类）

咖啡：煮水，冲泡咖啡，倒入杯中，加入糖和牛奶

茶：煮水，冲泡茶叶，倒入杯中，加入柠檬

```
class AbstractDrinking
{
public:
	virtual void Boil() = 0;
	virtual void Brew() = 0;
	virtual void Pour() = 0;
	virtual void Add() = 0;
	
	void make()
	{
		Boil();
		Brew();
		Pour();
		Add();
	}
};

class Coffee: public AbstractDrinking
{
public:
	void Boil()
	{
		cout<<"boiling pure water"<<endl;
	}
	void Brew()
	{
		cout<<"brew coffee"<<endl;
	}
	void Pour()
	{
		cout<<"Pour into coffee cup"<<endl;
	}
	void Add()
	{
		cout<<"Add sugar and milk"<<endl;
	}
};

class Tea: public AbstractDrinking
{
public:
	void Boil()
	{
		cout<<"boiling pure water"<<endl;
	}
	void Brew()
	{
		cout<<"brew tea"<<endl;
	}
	void Pour()
	{
		cout<<"Pour into tea cup"<<endl;
	}
	void Add()
	{
		cout<<"Add lemon"<<endl;
	}
};

void doWork(AbstractDrinking* abs)
{
	abs->make();
	delete abs;		//重要，记得释放
}

int main()
{
	doWork(new Coffee);
	doWork(new Tea);
}
```



#### 1.13.7 虚析构和纯虚析构

多态使用时，父类指针要指向子类对象。但是如果子类中有属性开辟到堆区，在释放父类指针时，无法运行到子类的析构，会造成内存泄漏。



总结：

- 正常情况下，父类的指针在析构时，不会调用子类中析构函数
- 如果子类中没有堆区数据，则不需要虚析构纯虚析构
- 不管是虚析构还是纯虚析构，都需要外部实现
- 有了纯虚析构后，这个类也是抽象类，无法实例化对象



```
class Animal
{
public:
	Animal()
	{
		cout<<"Animal gouzao"<<endl;
	}
	virtual void speak() = 0;
	
	~Animal()
	{
		cout<<"Animal xigou"<<endl;
	}
};

class Cat : public Animal
{
public:
	Cat(string name)
	{
		cout<<"Cat gouzao"<<endl;
		m_Name = new string(name);
	}
	
	void speak()
	{
		cout<< *m_Name <<"cat is speaking"<<endl;
	}
	
	~Cat()
	{
		if(m_Name != NULL)
		{
			cout<<"Cat xigou"<<endl;
			delete m_Name;
			m_Name = NULL;
		}
	}
	
	string* m_Name;
};

int main()
{
	Animal* animal = new Cat("Tom");
	animal->speak();
	delete animal;
}
```

输出：

```
polymorphic5.cpp -o polymorphic5 } ; if ($?) { .\polymorphic5 }
Animal gouzao
Cat gouzao
Tom cat is speaking
Animal xigou
```

发现Cat的析构函数没有调用，内存没有释放干净，内存泄漏。因为父类的指针在析构时，不会调用子类中析构函数！



**改正：Animal中变成虚析构**

```
class Animal
{
public:
	Animal()
	{
		cout<<"Animal gouzao"<<endl;
	}
	virtual void speak() = 0;
	
	virtual ~Animal()
	{
		cout<<"Animal xigou"<<endl;
	}
};

class Cat : public Animal
{
public:
	Cat(string name)
	{
		cout<<"Cat gouzao"<<endl;
		m_Name = new string(name);
	}
	
	void speak()
	{
		cout<< *m_Name <<"cat is speaking"<<endl;
	}
	
	~Cat()
	{
		if(m_Name != NULL)
		{
			cout<<"Cat xigou"<<endl;
			delete m_Name;
			m_Name = NULL;
		}
	}
	
	string* m_Name;
};

int main()
{
	Animal* animal = new Cat("Tom");
	animal->speak();
	delete animal;
}
```



纯虚析构

```
class Animal
{
public:
	Animal()
	{
		cout<<"Animal gouzao"<<endl;
	}
	virtual void speak() = 0;
	
	virtual ~Animal() = 0;
};
```

但直接这样写会报错：无法解析的外部命令



**原因：不管是虚析构还是纯虚析构，都需要外部实现**

改正：在类外实现

```
class Animal
{
public:
	Animal()
	{
		cout<<"Animal gouzao"<<endl;
	}
	virtual void speak() = 0;
	
	virtual ~Animal() = 0;
};

Animal::~Animal()
{
	cout<<"Animal 纯虚xigou"<<endl;
}
```

有了纯虚析构后，这个类也是抽象类，无法实例化对象。
