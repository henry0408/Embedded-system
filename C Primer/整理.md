# 1. 有关scanf

由于对字符解析方式及字符特点不同(e.g.数字中一般不会出现空格回车等特殊字符)，%d格式一般不会在连续输入时遇到问题。而%s和%c却会出现各种各样的问题，比如回车问题，空格问题等

## 1) 连续输入时的情况，对比下面两个代码块:

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf(" %c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

```
int main (void)
{
    int i;
    char c;
    scanf("%d", &i);
    printf("The number is %d\n", i);
    scanf("%c", &c);
    printf("The char is %c\n", c);

    return 0;
}
```

会发现下面的代码块在%c处会出现问题。

* 原因：scanf的缓冲机制和对字符的处理方式就造成了scanf对字符%c和字符串%s的读取时的各种意外

* 分析：
输入了i的值为3然后按回车，当前缓冲区中数据为”3\n”，由回车的作用scanf开始从缓冲区中读取一个%d控制的数据，也就是3，此时缓冲区中还剩”\n”；
对下一个scanf函数的格式控制是%c，这个情况下并不忽略先导的空白字符\n，而是直接赋给字符c了。想要查看缓冲区的内容，stdin[s1] 

* 综上：
scanf函数，根据格式的不同，对空白字符的处理也不同。\
对%d来说，对空白字符不敏感，通常都是作为结束符的；\
对%c来说，对回车符比较敏感，空格的做为一个普通字符处理的；\
对%s来说，回车和空格都是当前函数的结束字符，由于缓冲区stdin机制，这里又要特别注意 空格和回车对%s的影响。\
%s默认分隔符是所有的 white-spaces，输入后自动加入结束符"\0"，使其成为一个字符串(之所以加上\0，是和字符数组char[]的结束符有关的，C中是没有string这个类型的，是使用char[]结构实现字符串)。\
值得注意的是，即使输入字符的长度足够，%s是宁愿舍弃输入字符，也要把/0加上去的，作为字符串的结束。并且，scanf会忽略缓冲区开头的空格，直到遇到一个非空格字符，才开始向内存中读取数据


## 2) 处理%d（不清除缓冲区）
```
    int i,j;

    scanf("%d",&i);
    printf("The number i is %d\n", i);

    char ch;
    while ((ch = getchar()) != '\n'){
         continue;
    }

    scanf("%d",&j);
    printf("The number j is %d\n", j);
    
```
中间getchar的目的：判断缓冲区（用户输入的下一个字符是不是换行符）\
举例：\
如果用户输入：1 aqsda asa， 在不加getchar的情况下，j的值为一个不合法的数字。

加了getchar之后，在1被赋值给i后，会开始判断下一个字符是不是换行符，如果不是，则一直进入循环，不给j赋值。


# 2. 有关continue
![image](https://user-images.githubusercontent.com/58734009/210924009-a043a3ba-072a-449e-809c-4129e6fb9d16.png)

### 1) 用于do...while
```
#include <stdio.h>
 
int main ()
{
   int a = 10;
   
   do
   {
      if( a == 15)
      {
         a = a + 1;
         continue;
      }
      printf("a 的值： %d\n", a);
      a++;
     
   }while( a < 20 );
 
   return 0;
}
```

a = 10, 不执行if，输出：a 的值：10\
a = 11, 不执行if，输出：a 的值： 11\
a = 12, 不执行if，输出：a 的值： 12\
a = 13, 不执行if，输出：a 的值： 13\
a = 14, 不执行if，输出：a 的值： 14\
a = 15，执行if，a++后跳出当前的do while，进入下一个do while

a = 16, 不执行if，输出：a 的值： 16\
a = 17, 不执行if，输出：a 的值： 17\
a = 18, 不执行if，输出：a 的值： 18\
a = 19, 不执行if，输出：a 的值： 19\
a = 20, while不执行

```
int main(void)
{
    int  i=0, s=0;
    do
    { 
	if(i%2)
	{
	    printf("yes, ");
            i++;
            printf("i = %d, ", i);
            printf("s = %d \n", s);
	    continue;
	}
        printf("no, ");
	i++;
	s+=i; 
        printf("i = %d, ", i);
        printf("s = %d \n", s);
    }while(i < 5); 
	
    printf("%d\n",s);   
    return 0;
}
```
输出：

no, i = 1, s = 1\
yes, i = 2, s = 1\
no, i = 3, s = 4\
yes, i = 4, s = 4\
no, i = 5, s = 9\
9

# 3. 一些简单算法
## 1）倒置一个数组：注意：倒置用到的是“互换”的概念，而不是反向输出（可以新建一个数组）
```
#include <stdio.h>
int main (void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int t;
    int i = 0;
    int j = 4;

    while (i<j){
        t = a[i];
        a[i] = a[j];
        a[j] = t;

        i = i+1;
        j = j-1;
    }

    for (int z = 0; z< 5; z++){
        printf("%d\n", a[z]);
    }

    return 0;
}
```
相当于需要先知道一个数组的长度，从i开始，与倒数第i个（j）互换。

## 2）判断一个数字是不是回文数
```
int main (void)
{
    int sum = 0;
    int val, num;

    printf("Please enter your num: \n");
    scanf("%d", &val);

    num = val;
    while (num) //只要num不是0就一直循环
    {
        sum = sum * 10 + num % 10;
        num /= 10;
    }

    if (sum == val){
        printf("Yes \n");
    }
    else{
        printf("No \n");
    }

    return 0;
}
```

## 3）求斐波拉契序列中第n项的值
1 2 3 5 8 13 21 34 ...

```
int main (void)
{
    int f1 = 1;
    int f2 = 2;
    int value = 0;

    printf("Please enter a number n: \n");

    int n;
    scanf("%d", &n);

    if (n == 1){
        value = f1;
    }
    else if (n == 2){
        value = f2;
    }
    else{
        for (int i = 3; i <= n; ++i){
            value = f1+f2;
            f1 = f2;
            f2 = value;
        }
    }

    printf("The value of the nth number is %d\n", value);
    
    return 0;
}
```
## 4）判断是不是素数
```
bool is_prime (int num){
    int i;
    for (i = 2; i<= num; i = i+1){ //这个不用担心最后i = num + 1会对if判断造成问题，因为直接break掉了，i最后不会再+1
        if (num % i == 0){ //如果只有本身可以整除，即为素数
            break;
        }
    }
    if (i == num){
        return true;
    }
    else{
        return false;
    }
}
```

# 4. 指针

内存的编号不是位（bit），而是字节（1 byte = 8 bit）

```
int * p;
```
p是变量的名字，int * 表示变量p存放的是int类型变量的地址。

错误表示：
```
int * p;
int i = 3;
p = i
```

正确表示：
```
int * p;
int i = 3;
p = &i; //取地址
```

错误表示：
```
int * p;
double i = 3.5;
p = &i;
```

概念：
* 1. p保存了i的地址， 也就是说**p指向i**
* 2. 修改p的值不影响i的值；修改i的值也不影响p的值
* 3. 互换： * p 表示以p的内容为地址的变量的值
	```
	int *p;
	int i;
	p = &i;
	*p = i;
	```
* 4. 指针变量**不等于**指针\
指针变量：p；指针：&i

